============================= test session starts ==============================
platform linux -- Python 3.7.3, pytest-6.2.3, py-1.10.0, pluggy-0.13.1
rootdir: /tmp_amd/kamen/export/kamen/3/cs1531/automark/tempstore, configfile: pytest.ini
plugins: forked-1.3.0, xdist-2.2.1, hypothesis-6.1.1, timeout-1.4.2
collected 75 items

http_tests/channel_addowner_http_test.py F...F...                        [  5%]
http_tests/channel_details_http_test.py FFF                              [  9%]
http_tests/channel_invite_http_test.py ...F                              [ 14%]
http_tests/channel_join_http_test.py F.F                                 [ 18%]
http_tests/channel_leave_http_test.py FFF                                [ 22%]
http_tests/channel_messages_http_test.py FF.F                            [ 28%]
http_tests/channel_removeowner_http_test.py .....                        [ 34%]
http_tests/channels_create_http_test.py ...                              [ 38%]
http_tests/channels_list_http_test.py FFF                                [ 42%]
http_tests/channels_listall_http_test.py FFF                             [ 46%]
http_tests/dm_create_http_test.py ..                                     [ 49%]
http_tests/dm_details_http_test.py FFF                                   [ 53%]
http_tests/dm_invite_http_test.py ..                                     [ 56%]
http_tests/dm_leave_http_test.py ...                                     [ 60%]
http_tests/dm_list_http_test.py .                                        [ 61%]
http_tests/dm_messages_http_test.py FFFF                                 [ 66%]
http_tests/dm_remove_http_test.py ..                                     [ 69%]
http_tests/echo_http_test.py F                                           [ 70%]
http_tests/message_edit_http_test.py FFF                                 [ 74%]
http_tests/message_remove_http_test.py .FFF                              [ 80%]
http_tests/message_send_http_test.py FFF                                 [ 84%]
http_tests/message_senddm_v2_http_test.py F                              [ 85%]
http_tests/message_share_http_test.py FFFF                               [ 90%]
http_tests/search_http_test.py FF                                        [ 93%]
http_tests/users_all_http_test.py .

=================================== FAILURES ===================================
__________________________________ test_basic __________________________________

    def test_basic():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
        u_id = r.json().get('auth_user_id')
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # testing channel addowner v2
        addowner_data = {
            'token': token,
            'channel_id': ch_id,
            'u_id': u_id
        }
        r = requests.post(config.url + 'channel/addowner/v1', json=addowner_data)
>       assert r.status_code == 200
E       assert 400 == 200
E        +  where 400 = <Response [400]>.status_code

http_tests/channel_addowner_http_test.py:40: AssertionError
__________________________________ test_basic __________________________________

    def test_basic():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
        u_id = r.json().get('auth_user_id')
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # testing channel addowner v2
        addowner_data = {
            'token': token,
            'channel_id': ch_id,
            'u_id': u_id
        }
        r = requests.post(config.url + 'channel/addowner/v1', json=addowner_data)
>       assert r.status_code == 200
E       assert 400 == 200
E        +  where 400 = <Response [400]>.status_code

http_tests/channel_addowner_http_test.py:40: AssertionError
__________________________________ test_valid __________________________________

    def test_valid():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
        # testing channel details v2
        details_params = {
            'token': token,
            'channel_id': ch_id,
        }
        r = requests.get(config.url + 'channel/details/v2', json=details_params)
>       assert r.status_code == 200
E       assert 500 == 200
E        +  where 500 = <Response [500]>.status_code

http_tests/channel_details_http_test.py:45: AssertionError
_____________________________ test_invalid_channel _____________________________

    def test_invalid_channel():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
        # try to recall details of a non-existent channel and expect input
        # error
        invalid_id = 10
        details_params = {
            'token': token,
            'channel_id': invalid_id
        }
        r = requests.get(config.url + 'channel/details/v2', json=details_params)
>       assert r.status_code == 400
E       assert 500 == 400
E        +  where 500 = <Response [500]>.status_code

http_tests/channel_details_http_test.py:70: AssertionError
____________________________ test_unauthorised_user ____________________________

    def test_unauthorised_user():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # try to call channel_details when auth_user is not in the channel
        # and expect access error
        details_params = {
            'token': token,
            'channel_id': ch_id,
        }
        r = requests.get(config.url + 'channel/details/v2', json=details_params)
>       assert r.status_code == 403
E       assert 500 == 403
E        +  where 500 = <Response [500]>.status_code

http_tests/channel_details_http_test.py:105: AssertionError
______________________ test_invite_inviter_not_in_channel ______________________

    def test_invite_inviter_not_in_channel():
        requests.delete(config.url + 'clear/v1')
    
        # register 2 users
        reg_data1 = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        reg_data2 = {
            'email': 'test1@gmail.com',
            'password': 'testpw1234',
            'name_first': 'test_fname1',
            'name_last': 'test_lname1'
        }
    
        # acquire id and token of inviter and id of invitee
        r = requests.post(config.url + 'auth/register/v2', json=reg_data1)
        token1 = r.json().get('token')
        r = requests.post(config.url + 'auth/register/v2', json=reg_data2)
        user2_id = r.json().get('auth_user_id')
    
        # create a channel
        ch_data = {
            'token': token1,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # try to invite users to channel when inviter is not in channel and
        # expect access error
        invite_data = {
            'token': token1,
            'channel_id': ch_id,
            'u_id': user2_id
        }
        r = requests.post(config.url + 'channel/invite/v2', json=invite_data)
>       assert r.status_code == 403
E       assert 200 == 403
E        +  where 200 = <Response [200]>.status_code

http_tests/channel_invite_http_test.py:181: AssertionError
______________________________ test_join_channel _______________________________

    def test_join_channel():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        r = requests.post(config.url + 'channel/join/v2', json=join_data)
    
>       assert r.status_code == 200
E       assert 400 == 200
E        +  where 400 = <Response [400]>.status_code

http_tests/channel_join_http_test.py:40: AssertionError
______________________________ test_join_private _______________________________

    def test_join_private():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
        # create a private channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': False
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        r = requests.post(config.url + 'channel/join/v2', json=join_data)
    
>       assert(r.status_code == 403)
E       assert 400 == 403
E        +  where 400 = <Response [400]>.status_code

http_tests/channel_join_http_test.py:100: AssertionError
__________________________________ test_basic __________________________________

    def test_basic():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
        u_id = r.json().get('auth_user_id')
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # add user to channel as an owner
        addowner_data = {
            'token': token,
            'channel_id': ch_id,
            'u_id': u_id
        }
        r = requests.post(config.url + 'channel/addowner/v1', json=addowner_data)
    
        # user leave
        leave_data = {
            'token': token,
            'channel_id': ch_id
        }
        requests.post(config.url + 'channel/leave/v2', json=leave_data)
>       assert r.status_code == 200
E       assert 400 == 200
E        +  where 400 = <Response [400]>.status_code

http_tests/channel_leave_http_test.py:47: AssertionError
_____________________________ test_invalid_channel _____________________________

    def test_invalid_channel():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire tokenof user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
        invalid_id = 10
    
        # try to leave from non-existent channel and expect input error
        invalid_id = 10
        leave_data = {
            'token': token,
            'channel_id': invalid_id
        }
        r = requests.post(config.url + 'channel/leave/v2', json=leave_data)
>       assert r.status_code == 400
E       assert 404 == 400
E        +  where 404 = <Response [404]>.status_code

http_tests/channel_leave_http_test.py:73: AssertionError
____________________________ test_unauthorised_user ____________________________

    def test_unauthorised_user():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # try to call channel_leave when auth_user is not in the channel and expect failure
        leave_data = {
            'token': token,
            'channel_id': ch_id
        }
        r = requests.post(config.url + 'channel/leave/v2', json=leave_data)
>       assert r.status_code == 403
E       assert 404 == 403
E        +  where 404 = <Response [404]>.status_code

http_tests/channel_leave_http_test.py:107: AssertionError
___________________________ test_messages_nomessage ____________________________

    def test_messages_nomessage():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        r = requests.post(config.url + 'channel/join/v2', json=join_data)
    
        messages_params = {
            'token': token,
            'channel_id': ch_id,
            'start': 0
        }
        r = requests.get(config.url + 'channel/messages/v2', json=messages_params)
    
>       assert(r.status_code == 200)
E       assert 500 == 200
E        +  where 500 = <Response [500]>.status_code

http_tests/channel_messages_http_test.py:47: AssertionError
_________________________ test_messages_invalid_ch_id __________________________

    def test_messages_invalid_ch_id():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
        messages_params = {
            'token': token,
            'channel_id': 10,
            'start': 0
        }
    
        r = requests.get(config.url + 'channel/messages/v2', json=messages_params)
    
>       assert(r.status_code == 400)
E       assert 500 == 400
E        +  where 500 = <Response [500]>.status_code

http_tests/channel_messages_http_test.py:71: AssertionError
___________________________ test_messages_not_member ___________________________

    def test_messages_not_member():
        requests.delete(config.url + 'clear/v1')
    
        #owner of dm/caller of dm_create
        reg_data = {
            'email': 'test_auth@gmail.com',
            'password': 'test_pw_auth',
            'name_first': 'testf',
            'name_last': 'testl'
        }
    
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
        #create one user to pass in the list of users for dm create
        reg_data2 = {
            'email': 'test_second@gmail.com',
            'password': 'test_pw_second',
            'name_first': 'secondf',
            'name_last': 'secondl'
        }
        r = requests.post(config.url + 'auth/register/v2', json=reg_data2)
        token2 = r.json().get('token')
    
    
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        r = requests.post(config.url + 'channel/join/v2', json=join_data)
        #channel messages
        messages_params = {
            'token': token2,
            'channel_id': ch_id,
            'start': 0
        }
    
        r = requests.get(config.url + 'channel/messages/v2', json=messages_params)
    
>       assert(r.status_code == 403)
E       assert 500 == 403
E        +  where 500 = <Response [500]>.status_code

http_tests/channel_messages_http_test.py:160: AssertionError
____________________________ test_no_channels_list _____________________________

    def test_no_channels_list():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
    
        # create a channel 1
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
    
    
    
        # Testing listing the channels for user
        channels_list_data = {'token': token}
        r = requests.get(config.url + 'channels/list/v2', json=channels_list_data)
    
>       assert json.loads(r.text) == {'channels': []} and r.status_code == 200

http_tests/channels_list_http_test.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fa68af35358>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_______________________ test_two_channels_one_user_list ________________________

    def test_two_channels_one_user_list():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
    
        # create a channel 1
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id_1 = r.json().get('channel_id')
    
        # create a channel 2
        ch_data = {
            'token': token,
            'name': 'test_ch_2',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
    
    
        # Make user 1 join channel 1
        join_data = {
            'token': token,
            'channel_id': ch_id_1
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
    
        # Testing listing the channels for user
        channels_list_data = {'token': token}
        r = requests.get(config.url + 'channels/list/v2', json=channels_list_data)
    
>       assert json.loads(r.text) == {'channels': [{'all_members': [{'name_first': 'test_fname', 'name_last': 'test_lname', 'u_id': 0}], 'name': 'test_ch'}]} and r.status_code == 200

http_tests/channels_list_http_test.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fa68af35358>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_______________________ test_two_users_two_channels_list _______________________

    def test_two_users_two_channels_list():
        requests.delete(config.url + 'clear/v1')
    
        # register a user 1
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
    
        # register a user 2
        reg_data = {
            'email': 'test123@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token_2 = r.json().get('token')
    
        # create a channel 1
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id_1 = r.json().get('channel_id')
    
        # create a channel 2
        ch_data = {
            'token': token,
            'name': 'test_ch_2',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id_2 = r.json().get('channel_id')
    
        # Make user 1 join channel 1
        join_data = {
            'token': token,
            'channel_id': ch_id_1
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
    
        # Make user 2 join channel 2
        join_data = {
            'token': token_2,
            'channel_id': ch_id_2
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
    
        # Testing listing the channels for user
        channels_list_data = {'token': token_2}
        r = requests.get(config.url + 'channels/list/v2', json=channels_list_data)
    
>       assert json.loads(r.text) == {'channels': [{'all_members': [{'name_first': 'test_fname', 'name_last': 'test_lname', 'u_id': 1}], 'name': 'test_ch_2'}]} and r.status_code == 200

http_tests/channels_list_http_test.py:166: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fa68af35358>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
____________________________ test_no_channels_list _____________________________

    def test_no_channels_list():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
    
        # create a channel 1
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
    
    
    
        # Testing listing the channels for user
        channels_list_data = {'token': token}
        r = requests.get(config.url + 'channels/listall/v2', json=channels_list_data)
    
>       assert r.status_code == 200
E       assert 403 == 200
E        +  where 403 = <Response [403]>.status_code

http_tests/channels_listall_http_test.py:41: AssertionError
_______________________ test_two_channels_one_user_list ________________________

    def test_two_channels_one_user_list():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
    
        # create a channel 1
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id_1 = r.json().get('channel_id')
    
        # create a channel 2
        ch_data = {
            'token': token,
            'name': 'test_ch_2',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
    
    
        # Make user 1 join channel 1
        join_data = {
            'token': token,
            'channel_id': ch_id_1
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
    
        # Testing listing the channels for user
        channels_list_data = {'token': token}
        r = requests.get(config.url + 'channels/listall/v2', json=channels_list_data)
    
>       assert r.status_code == 200
E       assert 403 == 200
E        +  where 403 = <Response [403]>.status_code

http_tests/channels_listall_http_test.py:93: AssertionError
_______________________ test_two_users_two_channels_list _______________________

    def test_two_users_two_channels_list():
        requests.delete(config.url + 'clear/v1')
    
        # register a user 1
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
    
        # register a user 2
        reg_data = {
            'email': 'test123@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token_2 = r.json().get('token')
    
        # create a channel 1
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id_1 = r.json().get('channel_id')
    
        # create a channel 2
        ch_data = {
            'token': token,
            'name': 'test_ch_2',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id_2 = r.json().get('channel_id')
    
        # Make user 1 join channel 1
        join_data = {
            'token': token,
            'channel_id': ch_id_1
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
        # Make user 2 join channel 1
        join_data = {
            'token': token,
            'channel_id': ch_id_1
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
        # Make user 2 join channel 2
        join_data = {
            'token': token,
            'channel_id': ch_id_2
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
    
        # Testing listing the channels for user
        channels_list_data = {'token': token_2}
        r = requests.get(config.url + 'channels/listall/v2', json=channels_list_data)
    
>       assert r.status_code == 200
E       assert 403 == 200
E        +  where 403 = <Response [403]>.status_code

http_tests/channels_listall_http_test.py:171: AssertionError
____________________________ test_dm_details_basic _____________________________

    def test_dm_details_basic():
        requests.delete(config.url + 'clear/v1')
    
        #owner of dm/caller of dm_create
        reg_data = {
            'email': 'test_auth@gmail.com',
            'password': 'test_pw_auth',
            'name_first': 'testf',
            'name_last': 'testl'
        }
    
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
        #create one user to pass in the list of users for dm create
        reg_data2 = {
            'email': 'test_second@gmail.com',
            'password': 'test_pw_second',
            'name_first': 'secondf',
            'name_last': 'secondl'
        }
        r = requests.post(config.url + 'auth/register/v2', json=reg_data2)
        u_id2 = r.json().get('auth_user_id')
    
        create_data = {
            'token': token,
            'u_ids': [u_id2]
        }
    
        r = requests.post(config.url + 'dm/create/v1', json=create_data)
        dm_id = r.json().get('dm_id')
    
        details_params = {
            'token': token,
            'dm_id': dm_id
        }
    
        r = requests.get(config.url + 'dm/details/v1', json=details_params)
>       assert r.status_code == 200
E       assert 500 == 200
E        +  where 500 = <Response [500]>.status_code

http_tests/dm_details_http_test.py:44: AssertionError
_________________________ test_dm_details_invalid_dmid _________________________

    def test_dm_details_invalid_dmid():
        requests.delete(config.url + 'clear/v1')
    
        #owner of dm/caller of dm_create
        reg_data = {
            'email': 'test_auth@gmail.com',
            'password': 'test_pw_auth',
            'name_first': 'testf',
            'name_last': 'testl'
        }
    
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
        #create one user to pass in the list of users for dm create
        reg_data2 = {
            'email': 'test_second@gmail.com',
            'password': 'test_pw_second',
            'name_first': 'secondf',
            'name_last': 'secondl'
        }
        r = requests.post(config.url + 'auth/register/v2', json=reg_data2)
        u_id2 = r.json().get('auth_user_id')
    
        create_data = {
            'token': token,
            'u_ids': [u_id2]
        }
    
        r = requests.post(config.url + 'dm/create/v1', json=create_data)
    
        details_params = {
            'token': token,
            'dm_id': 3
        }
    
        r = requests.get(config.url + 'dm/details/v1', json=details_params)
>       assert r.status_code == 400
E       assert 500 == 400
E        +  where 500 = <Response [500]>.status_code

http_tests/dm_details_http_test.py:82: AssertionError
__________________________ test_dm_details_not_member __________________________

    def test_dm_details_not_member():
        requests.delete(config.url + 'clear/v1')
    
        #owner of dm/caller of dm_create
        reg_data = {
            'email': 'test_auth@gmail.com',
            'password': 'test_pw_auth',
            'name_first': 'testf',
            'name_last': 'testl'
        }
    
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
        #create one user to pass in the list of users for dm create
        reg_data2 = {
            'email': 'test_second@gmail.com',
            'password': 'test_pw_second',
            'name_first': 'secondf',
            'name_last': 'secondl'
        }
        r = requests.post(config.url + 'auth/register/v2', json=reg_data2)
        u_id2 = r.json().get('auth_user_id')
    
        reg_data3 = {
            'email': 'test_auth@gmail.com',
            'password': 'test_pw_auth',
            'name_first': 'testf',
            'name_last': 'testl'
        }
        r = requests.post(config.url + 'auth/register/v2', json=reg_data3)
>       token3 = r.json().get('token')

http_tests/dm_details_http_test.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fa68a5347b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>test_auth@gmail.com already taken</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fa68ade09f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
__________________________ test_dm_messages_nomessage __________________________

    def test_dm_messages_nomessage():
        requests.delete(config.url + 'clear/v1')
    
        #owner of dm/caller of dm_create
        reg_data = {
            'email': 'test_auth@gmail.com',
            'password': 'test_pw_auth',
            'name_first': 'testf',
            'name_last': 'testl'
        }
    
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
        create_data = {
            'token': token,
            'u_ids': []
        }
    
        r = requests.post(config.url + 'dm/create/v1', json=create_data)
        dm_id = r.json().get('dm_id')
    
        msg_params = {
            'token': token,
            'dm_id': dm_id,
            'start': 0
        }
    
        r = requests.get(config.url + 'dm/messages/v1', json=msg_params)
>       assert r.status_code == 200
E       assert 500 == 200
E        +  where 500 = <Response [500]>.status_code

http_tests/dm_messages_http_test.py:36: AssertionError
________________________ test_dm_messages_invalid_d_id _________________________

    def test_dm_messages_invalid_d_id():
        requests.delete(config.url + 'clear/v1')
    
        #owner of dm/caller of dm_create
        reg_data = {
            'email': 'test_auth@gmail.com',
            'password': 'test_pw_auth',
            'name_first': 'testf',
            'name_last': 'testl'
        }
    
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
        msg_params = {
            'token': token,
            'dm_id': 10,
            'start': 0
        }
    
        r = requests.get(config.url + 'dm/messages/v1', json=msg_params)
    
>       assert r.status_code == 400
E       assert 500 == 400
E        +  where 500 = <Response [500]>.status_code

http_tests/dm_messages_http_test.py:60: AssertionError
________________________ test_dm_messages_start_too_big ________________________

    def test_dm_messages_start_too_big():
        requests.delete(config.url + 'clear/v1')
    
        #owner of dm/caller of dm_create
        reg_data = {
            'email': 'test_auth@gmail.com',
            'password': 'test_pw_auth',
            'name_first': 'testf',
            'name_last': 'testl'
        }
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
        create_data = {
            'token': token,
            'u_ids': []
        }
    
        r = requests.post(config.url + 'dm/create/v1', json=create_data)
        dm_id = r.json().get('dm_id')
    
        msg_params = {
            'token': token,
            'dm_id': dm_id,
            'start': 2
        }
    
        r = requests.get(config.url + 'dm/messages/v1', json=msg_params)
    
>       assert r.status_code == 400
E       assert 500 == 400
E        +  where 500 = <Response [500]>.status_code

http_tests/dm_messages_http_test.py:91: AssertionError
_________________________ test_dm_messages_not_member __________________________

    def test_dm_messages_not_member():
        requests.delete(config.url + 'clear/v1')
    
        #owner of dm/caller of dm_create
        reg_data = {
            'email': 'test_auth@gmail.com',
            'password': 'test_pw_auth',
            'name_first': 'testf',
            'name_last': 'testl'
        }
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
        reg_data2 = {
            'email': 'test_second@gmail.com',
            'password': 'test_pw_second',
            'name_first': 'secondf',
            'name_last': 'secondl'
        }
        r = requests.post(config.url + 'auth/register/v2', json=reg_data2)
        token2 = r.json().get('token')
    
        create_data = {
            'token': token,
            'u_ids': []
        }
    
        r = requests.post(config.url + 'dm/create/v1', json=create_data)
        dm_id = r.json().get('dm_id')
    
        msg_params = {
            'token': token2,
            'dm_id': dm_id,
            'start': 0
        }
    
        r = requests.get(config.url + 'dm/messages/v1', json=msg_params)
    
>       assert r.status_code == 403
E       assert 500 == 403
E        +  where 500 = <Response [500]>.status_code

http_tests/dm_messages_http_test.py:131: AssertionError
__________________________________ test_echo ___________________________________

    def test_echo():
        # A simple test to check echo
        resp = requests.get(config.url + 'echo', params={'data': 'hello'})
>       assert json.loads(resp.text) == {'data': 'hello'}

http_tests/echo_http_test.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fa68af35358>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________________ test_valid_message_edit ____________________________

    def test_valid_message_edit():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
        # Testing sending message
        message = 'a'
        message_data = {'token': token, 'channel_id': ch_id, 'message': message}
        r = requests.post(config.url + 'message/send/v1', json=message_data)
>       message_id = r.json().get('message_id')

http_tests/message_edit_http_test.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fa68a5347b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fa68ade09f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
____________________________ test_long_message_edit ____________________________

    def test_long_message_edit():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
        # Testing sending message
        message = 'a'
        message_data = {'token': token, 'channel_id': ch_id, 'message': message}
        r = requests.post(config.url + 'message/send/v1', json=message_data)
>       message_id = r.json().get('message_id')

http_tests/message_edit_http_test.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fa68a5347b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fa68ade09f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_______________ test_message_not_sent_by_same_user_message_edit ________________

    def test_message_not_sent_by_same_user_message_edit():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
    
        # register a user 2
        reg_data = {
            'email': 'test123@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token_2 = r.json().get('token')
    
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
        # join user to channel
        join_data = {
            'token': token_2,
            'channel_id': ch_id
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
        # Sending message from user 1
        message = 'a'
        message_data = {'token': token, 'channel_id': ch_id, 'message': message}
        r = requests.post(config.url + 'message/send/v1', json=message_data)
>       message_id = r.json().get('message_id')

http_tests/message_edit_http_test.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fa68a5347b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fa68ade09f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
____________ test_message_remove_from_channel_not_sent_by_same_user ____________

    def test_message_remove_from_channel_not_sent_by_same_user():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
    
        # register a user
        reg_data = {
            'email': 'test123@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token_2 = r.json().get('token')
    
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
        # Sending message from user 1
        message = 'a'
        message_data = {'token': token, 'channel_id': ch_id, 'message': message}
        r = requests.post(config.url + 'message/send/v1', json=message_data)
>       message_id = r.json().get('message_id')

http_tests/message_remove_http_test.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fa68a5347b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fa68ade09f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_______________________ test_message_remove_from_channe ________________________

    def test_message_remove_from_channe():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
        # Sending message
        message = 'a'
        message_data = {'token': token, 'channel_id': ch_id, 'message': message}
        r = requests.post(config.url + 'message/send/v1', json=message_data)
>       message_id = r.json().get('message_id')

http_tests/message_remove_http_test.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fa68a5347b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fa68ade09f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_________________________ test_message_remove_from_dm __________________________

    def test_message_remove_from_dm():
        requests.delete(config.url + 'clear/v1')
    
        #owner of dm/caller of dm_create
        reg_data = {
            'email': 'test_auth@gmail.com',
            'password': 'test_pw_auth',
            'name_first': 'testf',
            'name_last': 'testl'
        }
    
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
        #create one user to pass in the list of users for dm create
        reg_data2 = {
            'email': 'test_second@gmail.com',
            'password': 'test_pw_second',
            'name_first': 'secondf',
            'name_last': 'secondl'
        }
        r = requests.post(config.url + 'auth/register/v2', json=reg_data2)
    
        u_id2 = r.json().get('auth_user_id')
    
        # Create DM 1
        create_data = {
            'token': token,
            'u_ids': [u_id2]
        }
    
        r = requests.post(config.url + 'dm/create/v1', json=create_data)
        dm_id_1 = r.json().get('dm_id')
    
        # Create DM 2
        create_data = {
            'token': token,
            'u_ids': [u_id2]
        }
    
        r = requests.post(config.url + 'dm/create/v1', json=create_data)
    
    
    
        # Sending a message to dm 1
        message = 'a'
        message_data = {'token': token, 'dm_id': dm_id_1, 'message': message}
        r = requests.post(config.url + '/message/senddm/v2', json=message_data)
>       message_id = r.json().get('message_id')

http_tests/message_remove_http_test.py:214: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fa68a5347b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fa68ade09f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
___________________________ test_valid_message_send ____________________________

    def test_valid_message_send():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
        # Testing sending message
        message = 'a'
        message_data = {'token': token, 'channel_id': ch_id, 'message': message}
        r = requests.post(config.url + 'message/send/v1', json=message_data)
    
>       assert r.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404]>.status_code

http_tests/message_send_http_test.py:51: AssertionError
____________________________ test_long_message_send ____________________________

    def test_long_message_send():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
        # Testing sending message
        message = 'a' * 1001
        message_data = {'token': token, 'channel_id': ch_id, 'message': message}
        r = requests.post(config.url + 'message/send/v1', json=message_data)
    
>       assert r.status_code == 400
E       assert 404 == 400
E        +  where 404 = <Response [404]>.status_code

http_tests/message_send_http_test.py:92: AssertionError
____________________ test_message_send_not_authorised_user _____________________

    def test_message_send_not_authorised_user():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
    
        # Testing sending message
        message = 'a'
        message_data = {'token': token, 'channel_id': ch_id, 'message': message}
        r = requests.post(config.url + 'message/send/v1', json=message_data)
    
>       assert r.status_code == 403
E       assert 404 == 403
E        +  where 404 = <Response [404]>.status_code

http_tests/message_send_http_test.py:127: AssertionError
____________________________ test_long_message_send ____________________________

    def test_long_message_send():
        requests.delete(config.url + 'clear/v1')
    
        #owner of dm/caller of dm_create
        reg_data = {
            'email': 'test_auth@gmail.com',
            'password': 'test_pw_auth',
            'name_first': 'testf',
            'name_last': 'testl'
        }
    
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
        #create one user to pass in the list of users for dm create
        reg_data2 = {
            'email': 'test_second@gmail.com',
            'password': 'test_pw_second',
            'name_first': 'secondf',
            'name_last': 'secondl'
        }
        r = requests.post(config.url + 'auth/register/v2', json=reg_data2)
        u_id2 = r.json().get('auth_user_id')
    
        create_data = {
            'token': token,
            'u_ids': [u_id2]
        }
    
        r = requests.post(config.url + 'dm/create/v1', json=create_data)
        dm_id = r.json().get('dm_id')
    
        # Testing sending message
        message = 'a' * 1001
        message_data = {'token': token, 'dm_id': dm_id, 'message': message}
        r = requests.post(config.url + 'message/senddm/v1', json=message_data)
    
>       assert r.status_code == 404
E       assert 400 == 404
E        +  where 400 = <Response [400]>.status_code

http_tests/message_senddm_v2_http_test.py:43: AssertionError
_________________ test_not_authorised_to_channel_message_share _________________

    def test_not_authorised_to_channel_message_share():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
    
        # create a channel 1
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # create a channel 2
        ch_data = {
            'token': token,
            'name': 'test_ch_2',
            'is_public': True
        }
    
        # acquire channel id 2
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id_2 = r.json().get('channel_id')
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
    
        # Sending a message to channel 1
        message = 'a'
        message_data = {'token': token, 'channel_id': ch_id, 'message': message}
        r = requests.post(config.url + 'message/send/v1', json=message_data)
>       message_id = r.json().get('message_id')

http_tests/message_share_http_test.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fa68a5347b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fa68ade09f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_____________________ test_valid_message_share_to_channel ______________________

    def test_valid_message_share_to_channel():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
    
        # create a channel 1
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # create a channel 2
        ch_data = {
            'token': token,
            'name': 'test_ch_2',
            'is_public': True
        }
    
        # acquire channel id 2
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id_2 = r.json().get('channel_id')
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id_2
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
        # Sending a message to channel 1
        message = 'a'
        message_data = {'token': token, 'channel_id': ch_id, 'message': message}
        r = requests.post(config.url + 'message/send/v1', json=message_data)
>       message_id = r.json().get('message_id')

http_tests/message_share_http_test.py:125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fa68a5347b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fa68ade09f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
___________________________ test_message_share_to_dm ___________________________

    def test_message_share_to_dm():
        requests.delete(config.url + 'clear/v1')
    
        #owner of dm/caller of dm_create
        reg_data = {
            'email': 'test_auth@gmail.com',
            'password': 'test_pw_auth',
            'name_first': 'testf',
            'name_last': 'testl'
        }
    
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
        #create one user to pass in the list of users for dm create
        reg_data2 = {
            'email': 'test_second@gmail.com',
            'password': 'test_pw_second',
            'name_first': 'secondf',
            'name_last': 'secondl'
        }
        r = requests.post(config.url + 'auth/register/v2', json=reg_data2)
    
        u_id2 = r.json().get('auth_user_id')
    
        # Create DM 1
        create_data = {
            'token': token,
            'u_ids': [u_id2]
        }
    
        r = requests.post(config.url + 'dm/create/v1', json=create_data)
        dm_id_1 = r.json().get('dm_id')
    
        # Create DM 2
        create_data = {
            'token': token,
            'u_ids': [u_id2]
        }
    
        r = requests.post(config.url + 'dm/create/v1', json=create_data)
        dm_id_2 = r.json().get('dm_id')
    
    
        # Sending a message to dm 1
        message = 'a'
        message_data = {'token': token, 'dm_id': dm_id_1, 'message': message}
        r = requests.post(config.url + '/message/senddm/v2', json=message_data)
>       message_id = r.json().get('message_id')

http_tests/message_share_http_test.py:183: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fa68a5347b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fa68ade09f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
___________________ test_message_share_to_dm_user_not_in_dm ____________________

    def test_message_share_to_dm_user_not_in_dm():
        requests.delete(config.url + 'clear/v1')
    
        #owner of dm/caller of dm_create
        reg_data = {
            'email': 'test_auth@gmail.com',
            'password': 'test_pw_auth',
            'name_first': 'testf',
            'name_last': 'testl'
        }
    
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
    
        #create one user to pass in the list of users for dm create
        reg_data2 = {
            'email': 'test_second@gmail.com',
            'password': 'test_pw_second',
            'name_first': 'secondf',
            'name_last': 'secondl'
        }
        r = requests.post(config.url + 'auth/register/v2', json=reg_data2)
        token2 = r.json().get('token')
        u_id2 = r.json().get('auth_user_id')
    
        # Create DM 1
        create_data = {
            'token': token2,
            'u_ids': [u_id2]
        }
    
        r = requests.post(config.url + 'dm/create/v1', json=create_data)
>       dm_id_1 = r.json().get('dm_id')

http_tests/message_share_http_test.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7fa68a5347b8>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>secondfsecondl is already a member of secondfsecondl, secondfsecondl</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7fa68ade09f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
__________________________________ test_valid __________________________________

    def test_valid():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
        search_data = {
            'token': token,
            'query_str': 'test'
        }
    
        r = requests.get(config.url + 'search/v2', json=search_data)
>       assert r.status_code == 200
E       assert 403 == 200
E        +  where 403 = <Response [403]>.status_code

http_tests/search_http_test.py:27: AssertionError
______________________________ test_long_querystr ______________________________

    def test_long_querystr():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
        long_str = 'a' * 1001
        search_data = {
            'token': token,
            'query_str': long_str
        }
    
        r = requests.get(config.url + 'search/v2', json=search_data)
>       assert r.status_code == 400
E       assert 403 == 400
E        +  where 403 = <Response [403]>.status_code

http_tests/search_http_test.py:88: AssertionError
=========================== short test summary info ============================
FAILED http_tests/channel_addowner_http_test.py::test_basic - assert 400 == 200
FAILED http_tests/channel_addowner_http_test.py::test_basic - assert 400 == 200
FAILED http_tests/channel_details_http_test.py::test_valid - assert 500 == 200
FAILED http_tests/channel_details_http_test.py::test_invalid_channel - assert...
FAILED http_tests/channel_details_http_test.py::test_unauthorised_user - asse...
FAILED http_tests/channel_invite_http_test.py::test_invite_inviter_not_in_channel
FAILED http_tests/channel_join_http_test.py::test_join_channel - assert 400 =...
FAILED http_tests/channel_join_http_test.py::test_join_private - assert 400 =...
FAILED http_tests/channel_leave_http_test.py::test_basic - assert 400 == 200
FAILED http_tests/channel_leave_http_test.py::test_invalid_channel - assert 4...
FAILED http_tests/channel_leave_http_test.py::test_unauthorised_user - assert...
FAILED http_tests/channel_messages_http_test.py::test_messages_nomessage - as...
FAILED http_tests/channel_messages_http_test.py::test_messages_invalid_ch_id
FAILED http_tests/channel_messages_http_test.py::test_messages_not_member - a...
FAILED http_tests/channels_list_http_test.py::test_no_channels_list - json.de...
FAILED http_tests/channels_list_http_test.py::test_two_channels_one_user_list
FAILED http_tests/channels_list_http_test.py::test_two_users_two_channels_list
FAILED http_tests/channels_listall_http_test.py::test_no_channels_list - asse...
FAILED http_tests/channels_listall_http_test.py::test_two_channels_one_user_list
FAILED http_tests/channels_listall_http_test.py::test_two_users_two_channels_list
FAILED http_tests/dm_details_http_test.py::test_dm_details_basic - assert 500...
FAILED http_tests/dm_details_http_test.py::test_dm_details_invalid_dmid - ass...
FAILED http_tests/dm_details_http_test.py::test_dm_details_not_member - simpl...
FAILED http_tests/dm_messages_http_test.py::test_dm_messages_nomessage - asse...
FAILED http_tests/dm_messages_http_test.py::test_dm_messages_invalid_d_id - a...
FAILED http_tests/dm_messages_http_test.py::test_dm_messages_start_too_big - ...
FAILED http_tests/dm_messages_http_test.py::test_dm_messages_not_member - ass...
FAILED http_tests/echo_http_test.py::test_echo - json.decoder.JSONDecodeError...
FAILED http_tests/message_edit_http_test.py::test_valid_message_edit - simple...
FAILED http_tests/message_edit_http_test.py::test_long_message_edit - simplej...
FAILED http_tests/message_edit_http_test.py::test_message_not_sent_by_same_user_message_edit
FAILED http_tests/message_remove_http_test.py::test_message_remove_from_channel_not_sent_by_same_user
FAILED http_tests/message_remove_http_test.py::test_message_remove_from_channe
FAILED http_tests/message_remove_http_test.py::test_message_remove_from_dm - ...
FAILED http_tests/message_send_http_test.py::test_valid_message_send - assert...
FAILED http_tests/message_send_http_test.py::test_long_message_send - assert ...
FAILED http_tests/message_send_http_test.py::test_message_send_not_authorised_user
FAILED http_tests/message_senddm_v2_http_test.py::test_long_message_send - as...
FAILED http_tests/message_share_http_test.py::test_not_authorised_to_channel_message_share
FAILED http_tests/message_share_http_test.py::test_valid_message_share_to_channel
FAILED http_tests/message_share_http_test.py::test_message_share_to_dm - simp...
FAILED http_tests/message_share_http_test.py::test_message_share_to_dm_user_not_in_dm
FAILED http_tests/search_http_test.py::test_valid - assert 403 == 200
FAILED http_tests/search_http_test.py::test_long_querystr - assert 403 == 400
======================== 44 failed, 31 passed in 3.39s =========================
