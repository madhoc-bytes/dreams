============================= test session starts ==============================
platform linux -- Python 3.7.3, pytest-6.2.3, py-1.10.0, pluggy-0.13.1 -- /usr/bin/python3
cachedir: .pytest_cache
hypothesis profile 'default' -> database=DirectoryBasedExampleDatabase('/tmp_amd/kamen/export/kamen/3/cs1531/automark/tempstore/.hypothesis/examples')
rootdir: /tmp_amd/kamen/export/kamen/3/cs1531/automark/tempstore, configfile: pytest.ini
plugins: forked-1.3.0, xdist-2.2.1, hypothesis-6.1.1, timeout-1.4.2
collecting ... collected 130 items

http_tests/auth_login_http_test.py::test_valid_login PASSED              [  0%]
http_tests/auth_login_http_test.py::test_invalid_email_login PASSED      [  1%]
http_tests/auth_login_http_test.py::test_unused_email_login PASSED       [  2%]
http_tests/auth_login_http_test.py::test_incorrect_password_login PASSED [  3%]
http_tests/auth_login_http_test.py::test_valid_login PASSED              [  3%]
http_tests/auth_login_http_test.py::test_invalid_email_login PASSED      [  3%]
http_tests/auth_login_http_test.py::test_unused_email_login PASSED       [  3%]
http_tests/auth_login_http_test.py::test_incorrect_password_login PASSED [  3%]
http_tests/auth_logout_http_test.py::test_logout_valid FAILED            [  3%]
http_tests/auth_register_http_test.py::test_basic PASSED                 [  4%]
http_tests/auth_register_http_test.py::test_invalid_email PASSED         [  5%]
http_tests/auth_register_http_test.py::test_auth_register_short_password PASSED [  6%]
http_tests/auth_register_http_test.py::test_auth_register_short_first_name FAILED [  6%]
http_tests/auth_register_http_test.py::test_auth_register_short_last_name PASSED [  7%]
http_tests/auth_register_http_test.py::test_auth_register_long_first_name PASSED [  8%]
http_tests/auth_register_http_test.py::test_auth_register_long_last_name PASSED [  9%]
http_tests/channel_addowner_http_test.py::test_basic FAILED              [ 10%]
http_tests/channel_addowner_http_test.py::test_invalid_channel PASSED    [ 10%]
http_tests/channel_addowner_http_test.py::test_already_owner PASSED      [ 11%]
http_tests/channel_addowner_http_test.py::test_no_privileges PASSED      [ 12%]
http_tests/channel_details_http_test.py::test_valid PASSED               [ 13%]
http_tests/channel_details_http_test.py::test_invalid_channel PASSED     [ 13%]
http_tests/channel_details_http_test.py::test_unauthorised_user FAILED   [ 14%]
http_tests/channel_invite_http_test.py::test_valid PASSED                [ 15%]
http_tests/channel_invite_http_test.py::test_invite_channel_invalid PASSED [ 16%]
http_tests/channel_invite_http_test.py::test_invite_user_invalid PASSED  [ 16%]
http_tests/channel_invite_http_test.py::test_invite_inviter_not_in_channel FAILED [ 17%]
http_tests/channel_join_http_test.py::test_join_channel FAILED           [ 18%]
http_tests/channel_join_http_test.py::test_join_invalid_uid PASSED       [ 19%]
http_tests/channel_join_http_test.py::test_join_private FAILED           [ 20%]
http_tests/channel_leave_http_test.py::test_basic FAILED                 [ 20%]
http_tests/channel_leave_http_test.py::test_invalid_channel FAILED       [ 21%]
http_tests/channel_leave_http_test.py::test_unauthorised_user FAILED     [ 22%]
http_tests/channel_messages_http_test.py::test_messages_nomessage PASSED [ 23%]
http_tests/channel_messages_http_test.py::test_messages_invalid_ch_id PASSED [ 23%]
http_tests/channel_messages_http_test.py::test_messages_start_too_big PASSED [ 24%]
http_tests/channel_messages_http_test.py::test_messages_not_member PASSED [ 25%]
http_tests/channel_removeowner_http_test.py::test_basic PASSED           [ 26%]
http_tests/channel_removeowner_http_test.py::test_invalid_channel PASSED [ 26%]
http_tests/channel_removeowner_http_test.py::test_not_an_owner PASSED    [ 27%]
http_tests/channel_removeowner_http_test.py::test_only_owner PASSED      [ 28%]
http_tests/channel_removeowner_http_test.py::test_no_privileges PASSED   [ 29%]
http_tests/channels_create_http_test.py::test_channels_create_public PASSED [ 30%]
http_tests/channels_create_http_test.py::test_channels_create_private PASSED [ 30%]
http_tests/channels_create_http_test.py::test_channels_create_invalid PASSED [ 31%]
http_tests/channels_list_http_test.py::test_no_channels_list FAILED      [ 32%]
http_tests/channels_list_http_test.py::test_two_channels_one_user_list FAILED [ 33%]
http_tests/channels_list_http_test.py::test_two_users_two_channels_list FAILED [ 33%]
http_tests/channels_listall_http_test.py::test_no_channels_list PASSED   [ 34%]
http_tests/channels_listall_http_test.py::test_two_channels_one_user_list PASSED [ 35%]
http_tests/channels_listall_http_test.py::test_two_users_two_channels_list PASSED [ 36%]
http_tests/dm_create_http_test.py::test_dm_create_basic PASSED           [ 36%]
http_tests/dm_create_http_test.py::test_dm_invalid_id PASSED             [ 37%]
http_tests/dm_details_http_test.py::test_dm_details_basic PASSED         [ 38%]
http_tests/dm_details_http_test.py::test_dm_details_invalid_dmid PASSED  [ 39%]
http_tests/dm_details_http_test.py::test_dm_details_not_member PASSED    [ 40%]
http_tests/dm_invite_http_test.py::test_invite_basic PASSED              [ 40%]
http_tests/dm_invite_http_test.py::test_invite_invalid_dmid PASSED       [ 41%]
http_tests/dm_leave_http_test.py::test_dm_leave_basic PASSED             [ 42%]
http_tests/dm_leave_http_test.py::test_dm_leave_invalid_dmid PASSED      [ 43%]
http_tests/dm_leave_http_test.py::test_dm_leave_not_member PASSED        [ 43%]
http_tests/dm_list_http_test.py::test_dm_list_basic PASSED               [ 44%]
http_tests/dm_messages_http_test.py::test_dm_messages_nomessage PASSED   [ 45%]
http_tests/dm_messages_http_test.py::test_dm_messages_invalid_d_id PASSED [ 46%]
http_tests/dm_messages_http_test.py::test_dm_messages_start_too_big PASSED [ 46%]
http_tests/dm_messages_http_test.py::test_dm_messages_not_member PASSED  [ 47%]
http_tests/dm_remove_http_test.py::test_dm_remove_basic PASSED           [ 48%]
http_tests/dm_remove_http_test.py::test_dm_remove_invalid_dmid PASSED    [ 49%]
http_tests/echo_http_test.py::test_echo FAILED                           [ 50%]
http_tests/message_edit_http_test.py::test_valid_message_edit FAILED     [ 50%]
http_tests/message_edit_http_test.py::test_long_message_edit FAILED      [ 51%]
http_tests/message_edit_http_test.py::test_message_not_sent_by_same_user_message_edit FAILED [ 52%]
http_tests/message_pin_http_test.py::test_valid_message_pin_channel FAILED [ 53%]
http_tests/message_pin_http_test.py::test_invalid_message_pin PASSED     [ 53%]
http_tests/message_pin_http_test.py::test_pin_message_pinned FAILED      [ 54%]
http_tests/message_pin_http_test.py::test_pin_message_not_authorised_user FAILED [ 55%]
http_tests/message_pin_http_test.py::test_pin_message_dm FAILED          [ 56%]
http_tests/message_react_http_test.py::test_message_react_basic FAILED   [ 56%]
http_tests/message_react_http_test.py::test_react_invalidmid PASSED      [ 57%]
http_tests/message_react_http_test.py::test_react_invalidreactid PASSED  [ 58%]
http_tests/message_react_http_test.py::test_already_reacted PASSED       [ 59%]
http_tests/message_remove_http_test.py::test_message_remove_from_channel_invalid_message FAILED [ 60%]
http_tests/message_remove_http_test.py::test_message_remove_from_channel_not_sent_by_same_user FAILED [ 60%]
http_tests/message_remove_http_test.py::test_message_remove_from_channe FAILED [ 61%]
http_tests/message_remove_http_test.py::test_message_remove_from_dm FAILED [ 62%]
http_tests/message_send_http_test.py::test_valid_message_send FAILED     [ 63%]
http_tests/message_send_http_test.py::test_long_message_send FAILED      [ 63%]
http_tests/message_send_http_test.py::test_message_send_not_authorised_user FAILED [ 64%]
http_tests/message_senddm_v2_http_test.py::test_long_message_send FAILED [ 65%]
http_tests/message_sendlater_http_test.py::test_message_sendlater_basic PASSED [ 66%]
http_tests/message_sendlater_http_test.py::test_message_sendlater_timeinpast FAILED [ 66%]
http_tests/message_sendlater_http_test.py::test_message_sendlater_invalid_ch PASSED [ 67%]
http_tests/message_sendlater_http_test.py::test_message_sendlater_longmsg PASSED [ 68%]
http_tests/message_sendlater_http_test.py::test_message_sendlater_notinch PASSED [ 69%]
http_tests/message_sendlaterdm_http_test.py::test_message_sendlaterdm_basic PASSED [ 70%]
http_tests/message_sendlaterdm_http_test.py::test_message_sendlaterdm_timeinpast FAILED [ 70%]
http_tests/message_sendlaterdm_http_test.py::test_message_sendlaterdm_invalid_dmid PASSED [ 71%]
http_tests/message_sendlaterdm_http_test.py::test_message_sendlaterdm_longstring PASSED [ 72%]
http_tests/message_sendlaterdm_http_test.py::test_sendlaterdm_not_in_dm PASSED [ 73%]
http_tests/message_share_http_test.py::test_not_authorised_to_channel_message_share FAILED [ 73%]
http_tests/message_share_http_test.py::test_valid_message_share_to_channel FAILED [ 74%]
http_tests/message_share_http_test.py::test_message_share_to_dm FAILED   [ 75%]
http_tests/message_share_http_test.py::test_message_share_to_dm_user_not_in_dm FAILED [ 76%]
http_tests/message_unpin_http_test.py::test_valid_message_pin_channel FAILED [ 76%]
http_tests/message_unpin_http_test.py::test_unpin_message_unpinned FAILED [ 77%]
http_tests/message_unpin_http_test.py::test_pin_message_not_authorised_user FAILED [ 78%]
http_tests/message_unpin_http_test.py::test_pin_message_dm FAILED        [ 79%]
http_tests/message_unreact_http_test.py::test_unreact_basic FAILED       [ 80%]
http_tests/message_unreact_http_test.py::test_unreact_invalidmid PASSED  [ 80%]
http_tests/message_unreact_http_test.py::test_unreact_invalidreactid PASSED [ 81%]
http_tests/message_unreact_http_test.py::test_unreact_has_no_react_from_user PASSED [ 82%]
http_tests/search_http_test.py::test_valid PASSED                        [ 83%]
http_tests/search_http_test.py::test_long_querystr PASSED                [ 83%]
http_tests/user_profile_http_test.py::test_valid_user_profile FAILED     [ 84%]
http_tests/user_profile_http_test.py::test_invalid_user FAILED           [ 85%]
http_tests/user_profile_setemail_http_test.py::test_valid_user_email FAILED [ 86%]
http_tests/user_profile_setemail_http_test.py::test_invalid_user_email FAILED [ 86%]
http_tests/user_profile_setemail_http_test.py::test_user_profile_setemail_used FAILED [ 87%]
http_tests/user_profile_sethandle_http_test.py::test_user_profile_sethandle_valid PASSED [ 88%]
http_tests/user_profile_sethandle_http_test.py::test_user_profile_sethandle_used FAILED [ 89%]
http_tests/user_profile_sethandle_http_test.py::test_new_handle_too_long PASSED [ 90%]
http_tests/user_profile_sethandle_http_test.py::test_new_handle_too_short PASSED [ 90%]
http_tests/user_profile_setname_http_test.py::test_user_profile_setname_valid FAILED [ 91%]
http_tests/user_profile_setname_http_test.py::test_first_name_too_short FAILED [ 92%]
http_tests/user_profile_setname_http_test.py::test_first_name_too_long FAILED [ 93%]
http_tests/user_profile_setname_http_test.py::test_last_name_too_short FAILED [ 93%]
http_tests/user_profile_setname_http_test.py::test_last_name_too_long FAILED [ 94%]
http_tests/user_stats_http_test.py::test_system PASSED                   [ 95%]
http_tests/users_all_http_test.py::test_system PASSED                    [ 96%]
http_tests/users_stats_http_test.py::test_system FAILED                  [ 96%]

=================================== FAILURES ===================================
______________________________ test_logout_valid _______________________________

    def test_logout_valid():
        data_register = {
                'email': 'abc@def.com',
                'password': 'Password01!',
                'name_first': 'John',
                'name_last': 'Smith'
            }
    
        data_login = {
            'email': 'abc@def.com',
            'password': 'Password01!'
        }
    
        requests.post(config.url + 'auth/register/v2', json=data_register)
        resp_login = requests.post(config.url + 'auth/login/v2', json=data_login)
        token = resp_login.json().get('token')
    
        data_logout = {
            'token': token
        }
    
    
        resp_logout = requests.post(config.url + 'auth/logout/v2', json=data_logout)
>       assert resp_logout.status_code == 200
E       assert 404 == 200
E         +404
E         -200

http_tests/auth_logout_http_test.py:34: AssertionError
_____________________ test_auth_register_short_first_name ______________________

    def test_auth_register_short_first_name():
        data = {
            'email': 'abc@def.com',
            'password': 'Password01!',
            'name_first': 'J',
            'name_last': 'Smith'
        }
    
        resp_register = requests.post(config.url + 'auth/register/v2', json=data)
>       assert resp_register.status_code == 400
E       assert 200 == 400
E         +200
E         -400

http_tests/auth_register_http_test.py:57: AssertionError
__________________________________ test_basic __________________________________

    def test_basic():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
        u_id = r.json().get('auth_user_id')
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # testing channel addowner v2
        addowner_data = {
            'token': token,
            'channel_id': ch_id,
            'u_id': u_id
        }
        r = requests.post(config.url + 'channel/addowner/v1', json=addowner_data)
>       assert r.status_code == 200
E       assert 400 == 200
E         +400
E         -200

http_tests/channel_addowner_http_test.py:40: AssertionError
____________________________ test_unauthorised_user ____________________________

    def test_unauthorised_user():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json()['token']
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json()['channel_id']
    
        # try to call channel_details when auth_user is not in the channel
        # and expect access error
        details_params = {
            'token': token,
            'channel_id': ch_id,
        }
        r = requests.get(config.url + 'channel/details/v2', params=details_params)
>       assert r.status_code == 403
E       assert 200 == 403
E         +200
E         -403

http_tests/channel_details_http_test.py:105: AssertionError
______________________ test_invite_inviter_not_in_channel ______________________

    def test_invite_inviter_not_in_channel():
        requests.delete(config.url + 'clear/v1')
    
        # register 2 users
        reg_data1 = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        reg_data2 = {
            'email': 'test1@gmail.com',
            'password': 'testpw1234',
            'name_first': 'test_fname1',
            'name_last': 'test_lname1'
        }
    
        # acquire id and token of inviter and id of invitee
        r = requests.post(config.url + 'auth/register/v2', json=reg_data1)
        token1 = r.json().get('token')
        r = requests.post(config.url + 'auth/register/v2', json=reg_data2)
        user2_id = r.json().get('auth_user_id')
    
        # create a channel
        ch_data = {
            'token': token1,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # try to invite users to channel when inviter is not in channel and
        # expect access error
        invite_data = {
            'token': token1,
            'channel_id': ch_id,
            'u_id': user2_id
        }
        r = requests.post(config.url + 'channel/invite/v2', json=invite_data)
>       assert r.status_code == 403
E       assert 200 == 403
E         +200
E         -403

http_tests/channel_invite_http_test.py:181: AssertionError
______________________________ test_join_channel _______________________________

    def test_join_channel():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        r = requests.post(config.url + 'channel/join/v2', json=join_data)
    
>       assert r.status_code == 200
E       assert 400 == 200
E         +400
E         -200

http_tests/channel_join_http_test.py:40: AssertionError
______________________________ test_join_private _______________________________

    def test_join_private():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
        # create a private channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': False
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        r = requests.post(config.url + 'channel/join/v2', json=join_data)
    
>       assert(r.status_code == 403)
E       assert 400 == 403
E         +400
E         -403

http_tests/channel_join_http_test.py:100: AssertionError
__________________________________ test_basic __________________________________

    def test_basic():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
        u_id = r.json().get('auth_user_id')
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # add user to channel as an owner
        addowner_data = {
            'token': token,
            'channel_id': ch_id,
            'u_id': u_id
        }
        r = requests.post(config.url + 'channel/addowner/v1', json=addowner_data)
    
        # user leave
        leave_data = {
            'token': token,
            'channel_id': ch_id
        }
        requests.post(config.url + 'channel/leave/v2', json=leave_data)
>       assert r.status_code == 200
E       assert 400 == 200
E         +400
E         -200

http_tests/channel_leave_http_test.py:47: AssertionError
_____________________________ test_invalid_channel _____________________________

    def test_invalid_channel():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire tokenof user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
        invalid_id = 10
    
        # try to leave from non-existent channel and expect input error
        invalid_id = 10
        leave_data = {
            'token': token,
            'channel_id': invalid_id
        }
        r = requests.post(config.url + 'channel/leave/v2', json=leave_data)
>       assert r.status_code == 400
E       assert 404 == 400
E         +404
E         -400

http_tests/channel_leave_http_test.py:73: AssertionError
____________________________ test_unauthorised_user ____________________________

    def test_unauthorised_user():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # try to call channel_leave when auth_user is not in the channel and expect failure
        leave_data = {
            'token': token,
            'channel_id': ch_id
        }
        r = requests.post(config.url + 'channel/leave/v2', json=leave_data)
>       assert r.status_code == 403
E       assert 404 == 403
E         +404
E         -403

http_tests/channel_leave_http_test.py:107: AssertionError
____________________________ test_no_channels_list _____________________________

    def test_no_channels_list():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json()['token']
    
    
        # create a channel 1
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
    
        # Testing listing the channels for user
        channels_list_data = {'token': token}
        r = requests.get(config.url + 'channels/list/v2', params=channels_list_data)
    
>       assert json.loads(r.text) == {'channels': []} and r.status_code == 200
E       AssertionError: assert ({'channels': [{'channel_id': 72, 'name': 'test_ch'}]} == {'channels': []}
E         Differing items:
E         {'channels': [{'channel_id': 72, 'name': 'test_ch'}]} != {'channels': []}
E         Full diff:
E         - {'channels': []}
E         + {'channels': [{'channel_id': 72, 'name': 'test_ch'}]})

http_tests/channels_list_http_test.py:39: AssertionError
_______________________ test_two_channels_one_user_list ________________________

    def test_two_channels_one_user_list():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json()['token']
    
    
        # create a channel 1
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id_1 = r.json()['channel_id']
    
        # create a channel 2
        ch_data = {
            'token': token,
            'name': 'test_ch_2',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
    
    
        # Make user 1 join channel 1
        join_data = {
            'token': token,
            'channel_id': ch_id_1
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
    
        # Testing listing the channels for user
        channels_list_data = {'token': token}
        r = requests.get(config.url + 'channels/list/v2', params=channels_list_data)
    
>       assert json.loads(r.text) == {'channels': [{'all_members': [{'name_first': 'test_fname', 'name_last': 'test_lname', 'u_id': 0}], 'name': 'test_ch'}]} and r.status_code == 200
E       AssertionError: assert ({'channels': [{'channel_id': 75, 'name': 'test_ch_2'},\n              {'channel_id': 74, 'name': 'test_ch'}]} == {'channels': [{'all_members': [{'name_first': 'test_fname',\n                                'name_last': 'test_lname',\n                                'u_id': 0}],\n               'name': 'test_ch'}]}
E         Differing items:
E         {'channels': [{'channel_id': 75, 'name': 'test_ch_2'}, {'channel_id': 74, 'name': 'test_ch'}]} != {'channels': [{'all_members': [{'name_first': 'test_fname', 'name_last': 'test_lname', 'u_id': 0}], 'name': 'test_ch'}]}
E         Full diff:
E           {
E         -  'channels': [{'all_members': [{'name_first': 'test_fname',
E         -                                 'name_last': 'test_lname',
E         -                                 'u_id': 0}],
E         +  'channels': [{'channel_id': 75,
E         +                'name': 'test_ch_2'},
E         +               {'channel_id': 74,
E                          'name': 'test_ch'}],
E           })

http_tests/channels_list_http_test.py:92: AssertionError
_______________________ test_two_users_two_channels_list _______________________

    def test_two_users_two_channels_list():
        requests.delete(config.url + 'clear/v1')
    
        # register a user 1
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json()['token']
    
    
        # register a user 2
        reg_data = {
            'email': 'test123@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token_2 = r.json()['token']
    
        # create a channel 1
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id_1 = r.json()['channel_id']
    
        # create a channel 2
        ch_data = {
            'token': token,
            'name': 'test_ch_2',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id_2 = r.json()['channel_id']
    
        # Make user 1 join channel 1
        join_data = {
            'token': token,
            'channel_id': ch_id_1
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
    
        # Make user 2 join channel 2
        join_data = {
            'token': token_2,
            'channel_id': ch_id_2
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
    
        # Testing listing the channels for user
        channels_list_data = {'token': token_2}
        r = requests.get(config.url + 'channels/list/v2', params=channels_list_data)
    
>       assert json.loads(r.text) == {'channels': [{'all_members': [{'name_first': 'test_fname', 'name_last': 'test_lname', 'u_id': 1}], 'name': 'test_ch_2'}]} and r.status_code == 200
E       AssertionError: assert ({'channels': [{'channel_id': 79, 'name': 'test_ch_2'}]} == {'channels': [{'all_members': [{'name_first': 'test_fname',\n                                'name_last': 'test_lname',\n                                'u_id': 1}],\n               'name': 'test_ch_2'}]}
E         Differing items:
E         {'channels': [{'channel_id': 79, 'name': 'test_ch_2'}]} != {'channels': [{'all_members': [{'name_first': 'test_fname', 'name_last': 'test_lname', 'u_id': 1}], 'name': 'test_ch_2'}]}
E         Full diff:
E           {
E         +  'channels': [{'channel_id': 79,
E         -  'channels': [{'all_members': [{'name_first': 'test_fname',
E         -                                 'name_last': 'test_lname',
E         -                                 'u_id': 1}],
E                          'name': 'test_ch_2'}],
E           })

http_tests/channels_list_http_test.py:164: AssertionError
__________________________________ test_echo ___________________________________

    def test_echo():
        # A simple test to check echo
        resp = requests.get(config.url + 'echo', params={'data': 'hello'})
>       assert json.loads(resp.text) == {'data': 'hello'}

http_tests/echo_http_test.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f7e4c741470>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________________ test_valid_message_edit ____________________________

    def test_valid_message_edit():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
        # Testing sending message
        message = 'a'
        message_data = {'token': token, 'channel_id': ch_id, 'message': message}
        r = requests.post(config.url + 'message/send/v1', json=message_data)
>       message_id = r.json().get('message_id')

http_tests/message_edit_http_test.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7e4bd54748>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7e4c5ae9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
____________________________ test_long_message_edit ____________________________

    def test_long_message_edit():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
        # Testing sending message
        message = 'a'
        message_data = {'token': token, 'channel_id': ch_id, 'message': message}
        r = requests.post(config.url + 'message/send/v1', json=message_data)
>       message_id = r.json().get('message_id')

http_tests/message_edit_http_test.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7e4bd54748>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7e4c5ae9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_______________ test_message_not_sent_by_same_user_message_edit ________________

    def test_message_not_sent_by_same_user_message_edit():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
    
        # register a user 2
        reg_data = {
            'email': 'test123@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token_2 = r.json().get('token')
    
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
        # join user to channel
        join_data = {
            'token': token_2,
            'channel_id': ch_id
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
        # Sending message from user 1
        message = 'a'
        message_data = {'token': token, 'channel_id': ch_id, 'message': message}
        r = requests.post(config.url + 'message/send/v1', json=message_data)
>       message_id = r.json().get('message_id')

http_tests/message_edit_http_test.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7e4bd54748>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7e4c5ae9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
________________________ test_valid_message_pin_channel ________________________

    def test_valid_message_pin_channel():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
        # sending message
        message = 'a'
        message_data = {'token': token, 'channel_id': ch_id, 'message': message}
        r = requests.post(config.url + 'message/send/v1', json=message_data)
>       message_id = r.json().get('message_id')

http_tests/message_pin_http_test.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7e4bd54748>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7e4c5ae9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
___________________________ test_pin_message_pinned ____________________________

    def test_pin_message_pinned():
    
        requests.delete(config.url + '/clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + '/auth/register/v2', json=reg_data)
        token = r.json()['token']
    
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + '/channels/create/v2', json=ch_data)
        ch_id = r.json()['channel_id']
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        requests.post(config.url + '/channel/join/v2', json=join_data)
    
    
        message = 'a'
        message_data = {'token': token, 'channel_id': ch_id, 'message': message}
        r = requests.post(config.url + '/message/send/v1', json=message_data)
>       message_id = r.json()['message_id']

http_tests/message_pin_http_test.py:144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7e4bd54748>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7e4c5ae9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_____________________ test_pin_message_not_authorised_user _____________________

    def test_pin_message_not_authorised_user():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
        # register a user
        reg_data = {
            'email': 'test123@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token2 = r.json().get('token')
    
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
        # Testing sending message
        message = 'a'
        message_data = {'token': token, 'channel_id': ch_id, 'message': message}
        r = requests.post(config.url + 'message/send/v1', json=message_data)
>       message_id = r.json().get('message_id')

http_tests/message_pin_http_test.py:203: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7e4bd54748>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7e4c5ae9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_____________________________ test_pin_message_dm ______________________________

    def test_pin_message_dm():
        requests.delete(config.url + 'clear/v1')
    
        #owner of dm/caller of dm_create
        reg_data = {
            'email': 'test_auth@gmail.com',
            'password': 'test_pw_auth',
            'name_first': 'testf',
            'name_last': 'testl'
        }
    
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
        auth_id = r.json().get('auth_user_id')
    
    
        # Create DM 1
        create_data = {
            'token': token,
            'u_ids': [auth_id]
        }
    
        r = requests.post(config.url + 'dm/create/v1', json=create_data)
>       dm_id_1 = r.json().get('dm_id')

http_tests/message_pin_http_test.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7e4bd54748>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>testftestl is already a member of testftestl, testftestl</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7e4c5ae9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
___________________________ test_message_react_basic ___________________________

    def test_message_react_basic():
        requests.delete(config.url + 'clear/v1')
    
        reg_data = {
            'email': 'test_auth@gmail.com',
            'password': 'test_pw_auth',
            'name_first': 'testf',
            'name_last': 'testl'
        }
    
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        r = requests.post(config.url + 'channel/join/v2', json=join_data)
    
        send_data = {
            'token': token,
            'channel_id': ch_id,
            'message': 'string',
        }
    
        r = requests.post(config.url + 'message/send/v1', json=send_data)
    
        react_data = {
            'token': token,
            'message_id': 0,
            'react_id': 1,
        }
    
        r = requests.post(config.url + 'message/react/v1', json=react_data)
>       assert r.status_code == 200
E       assert 400 == 200
E         +400
E         -200

http_tests/message_react_http_test.py:53: AssertionError
_______________ test_message_remove_from_channel_invalid_message _______________

    def test_message_remove_from_channel_invalid_message():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
        # Sending message
        message = 'a'
        message_data = {'token': token, 'channel_id': ch_id, 'message': message}
        r = requests.post(config.url + 'message/send/v1', json=message_data)
>       message_id = r.json().get('message_id')

http_tests/message_remove_http_test.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7e4bd54748>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7e4c5ae9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
____________ test_message_remove_from_channel_not_sent_by_same_user ____________

    def test_message_remove_from_channel_not_sent_by_same_user():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
    
        # register a user
        reg_data = {
            'email': 'test123@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token_2 = r.json().get('token')
    
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
        # Sending message from user 1
        message = 'a'
        message_data = {'token': token, 'channel_id': ch_id, 'message': message}
        r = requests.post(config.url + 'message/send/v1', json=message_data)
>       message_id = r.json().get('message_id')

http_tests/message_remove_http_test.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7e4bd54748>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7e4c5ae9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_______________________ test_message_remove_from_channe ________________________

    def test_message_remove_from_channe():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
        # Sending message
        message = 'a'
        message_data = {'token': token, 'channel_id': ch_id, 'message': message}
        r = requests.post(config.url + 'message/send/v1', json=message_data)
>       message_id = r.json().get('message_id')

http_tests/message_remove_http_test.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7e4bd54748>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7e4c5ae9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_________________________ test_message_remove_from_dm __________________________

    def test_message_remove_from_dm():
        requests.delete(config.url + 'clear/v1')
    
        #owner of dm/caller of dm_create
        reg_data = {
            'email': 'test_auth@gmail.com',
            'password': 'test_pw_auth',
            'name_first': 'testf',
            'name_last': 'testl'
        }
    
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
        #create one user to pass in the list of users for dm create
        reg_data2 = {
            'email': 'test_second@gmail.com',
            'password': 'test_pw_second',
            'name_first': 'secondf',
            'name_last': 'secondl'
        }
        r = requests.post(config.url + 'auth/register/v2', json=reg_data2)
    
        u_id2 = r.json().get('auth_user_id')
    
        # Create DM 1
        create_data = {
            'token': token,
            'u_ids': [u_id2]
        }
    
        r = requests.post(config.url + 'dm/create/v1', json=create_data)
        dm_id_1 = r.json().get('dm_id')
    
        # Create DM 2
        create_data = {
            'token': token,
            'u_ids': [u_id2]
        }
    
        r = requests.post(config.url + 'dm/create/v1', json=create_data)
    
    
    
        # Sending a message to dm 1
        message = 'a'
        message_data = {'token': token, 'dm_id': dm_id_1, 'message': message}
        r = requests.post(config.url + '/message/senddm/v2', json=message_data)
>       message_id = r.json().get('message_id')

http_tests/message_remove_http_test.py:213: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7e4bd54748>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7e4c5ae9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
___________________________ test_valid_message_send ____________________________

    def test_valid_message_send():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
        # Testing sending message
        message = 'a'
        message_data = {'token': token, 'channel_id': ch_id, 'message': message}
        r = requests.post(config.url + 'message/send/v1', json=message_data)
    
        #result = message_exists(message_id)
        #assert result == True
>       assert r.status_code == 200
E       assert 404 == 200
E         +404
E         -200

http_tests/message_send_http_test.py:55: AssertionError
____________________________ test_long_message_send ____________________________

    def test_long_message_send():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
        # Testing sending message
        message = 'a' * 1001
        message_data = {'token': token, 'channel_id': ch_id, 'message': message}
        r = requests.post(config.url + 'message/send/v1', json=message_data)
    
>       assert r.status_code == 400
E       assert 404 == 400
E         +404
E         -400

http_tests/message_send_http_test.py:96: AssertionError
____________________ test_message_send_not_authorised_user _____________________

    def test_message_send_not_authorised_user():
    
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
    
        # Testing sending message
        message = 'a'
        message_data = {'token': token, 'channel_id': ch_id, 'message': message}
        r = requests.post(config.url + 'message/send/v1', json=message_data)
    
>       assert r.status_code == 403
E       assert 404 == 403
E         +404
E         -403

http_tests/message_send_http_test.py:132: AssertionError
____________________________ test_long_message_send ____________________________

    def test_long_message_send():
        requests.delete(config.url + 'clear/v1')
    
        #owner of dm/caller of dm_create
        reg_data = {
            'email': 'test_auth@gmail.com',
            'password': 'test_pw_auth',
            'name_first': 'testf',
            'name_last': 'testl'
        }
    
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
        #create one user to pass in the list of users for dm create
        reg_data2 = {
            'email': 'test_second@gmail.com',
            'password': 'test_pw_second',
            'name_first': 'secondf',
            'name_last': 'secondl'
        }
        r = requests.post(config.url + 'auth/register/v2', json=reg_data2)
        u_id2 = r.json().get('auth_user_id')
    
        create_data = {
            'token': token,
            'u_ids': [u_id2]
        }
    
        r = requests.post(config.url + 'dm/create/v1', json=create_data)
        dm_id = r.json().get('dm_id')
    
        # Testing sending message
        message = 'a' * 1001
        message_data = {'token': token, 'dm_id': dm_id, 'message': message}
        r = requests.post(config.url + 'message/senddm/v1', json=message_data)
    
>       assert r.status_code == 404
E       assert 400 == 404
E         +400
E         -404

http_tests/message_senddm_v2_http_test.py:43: AssertionError
______________________ test_message_sendlater_timeinpast _______________________

    def test_message_sendlater_timeinpast():
        requests.delete(config.url + 'clear/v1')
    
        reg_data = {
            'email': 'test_auth@gmail.com',
            'password': 'test_pw_auth',
            'name_first': 'testf',
            'name_last': 'testl'
        }
    
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        r = requests.post(config.url + 'channel/join/v2', json=join_data)
    
        time_sent = int(datetime.now().replace(tzinfo=timezone.utc).timestamp()) - 1
    
        sendlater_data = {
            'token': token,
            'channel_id': ch_id,
            'message': 'string',
            'time_sent': time_sent,
        }
    
        r = requests.post(config.url + 'message/sendlater/v1', json=sendlater_data)
    
>       assert r.status_code == 400
E       assert 200 == 400
E         +200
E         -400

http_tests/message_sendlater_http_test.py:92: AssertionError
_____________________ test_message_sendlaterdm_timeinpast ______________________

    def test_message_sendlaterdm_timeinpast():
        requests.delete(config.url + 'clear/v1')
    
        reg_data = {
            'email': 'test_auth@gmail.com',
            'password': 'test_pw_auth',
            'name_first': 'testf',
            'name_last': 'testl'
        }
    
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
        dm_data = {
            'token': token,
            'u_ids': [],
        }
    
        r = requests.post(config.url + 'dm/create/v1', json=dm_data)
        dm_id = r.json().get('dm_id')
    
        time_sent = int(datetime.now().replace(tzinfo=timezone.utc).timestamp()) - 1
        sendlater_data = {
            'token': token,
            'dm_id': dm_id,
            'message': 'string',
            'time_sent': time_sent,
        }
    
        r = requests.post(config.url + 'message/sendlaterdm/v1', json=sendlater_data)
    
>       assert r.status_code == 400
E       assert 200 == 400
E         +200
E         -400

http_tests/message_sendlaterdm_http_test.py:73: AssertionError
_________________ test_not_authorised_to_channel_message_share _________________

    def test_not_authorised_to_channel_message_share():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
    
        # create a channel 1
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # create a channel 2
        ch_data = {
            'token': token,
            'name': 'test_ch_2',
            'is_public': True
        }
    
        # acquire channel id 2
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id_2 = r.json().get('channel_id')
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
    
        # Sending a message to channel 1
        message = 'a'
        message_data = {'token': token, 'channel_id': ch_id, 'message': message}
        r = requests.post(config.url + 'message/send/v1', json=message_data)
>       message_id = r.json().get('message_id')

http_tests/message_share_http_test.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7e4bd54748>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7e4c5ae9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_____________________ test_valid_message_share_to_channel ______________________

    def test_valid_message_share_to_channel():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
    
        # create a channel 1
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # create a channel 2
        ch_data = {
            'token': token,
            'name': 'test_ch_2',
            'is_public': True
        }
    
        # acquire channel id 2
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id_2 = r.json().get('channel_id')
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id_2
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
        # Sending a message to channel 1
        message = 'a'
        message_data = {'token': token, 'channel_id': ch_id, 'message': message}
        r = requests.post(config.url + 'message/send/v1', json=message_data)
>       message_id = r.json().get('message_id')

http_tests/message_share_http_test.py:125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7e4bd54748>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7e4c5ae9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
___________________________ test_message_share_to_dm ___________________________

    def test_message_share_to_dm():
        requests.delete(config.url + 'clear/v1')
    
        #owner of dm/caller of dm_create
        reg_data = {
            'email': 'test_auth@gmail.com',
            'password': 'test_pw_auth',
            'name_first': 'testf',
            'name_last': 'testl'
        }
    
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
        #create one user to pass in the list of users for dm create
        reg_data2 = {
            'email': 'test_second@gmail.com',
            'password': 'test_pw_second',
            'name_first': 'secondf',
            'name_last': 'secondl'
        }
        r = requests.post(config.url + 'auth/register/v2', json=reg_data2)
    
        u_id2 = r.json().get('auth_user_id')
    
        # Create DM 1
        create_data = {
            'token': token,
            'u_ids': [u_id2]
        }
    
        r = requests.post(config.url + 'dm/create/v1', json=create_data)
        dm_id_1 = r.json().get('dm_id')
    
        # Create DM 2
        create_data = {
            'token': token,
            'u_ids': [u_id2]
        }
    
        r = requests.post(config.url + 'dm/create/v1', json=create_data)
        dm_id_2 = r.json().get('dm_id')
    
    
        # Sending a message to dm 1
        message = 'a'
        message_data = {'token': token, 'dm_id': dm_id_1, 'message': message}
        r = requests.post(config.url + '/message/senddm/v2', json=message_data)
>       message_id = r.json().get('message_id')

http_tests/message_share_http_test.py:183: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7e4bd54748>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7e4c5ae9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
___________________ test_message_share_to_dm_user_not_in_dm ____________________

    def test_message_share_to_dm_user_not_in_dm():
        requests.delete(config.url + 'clear/v1')
    
        #owner of dm/caller of dm_create
        reg_data = {
            'email': 'test_auth@gmail.com',
            'password': 'test_pw_auth',
            'name_first': 'testf',
            'name_last': 'testl'
        }
    
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
    
        #create one user to pass in the list of users for dm create
        reg_data2 = {
            'email': 'test_second@gmail.com',
            'password': 'test_pw_second',
            'name_first': 'secondf',
            'name_last': 'secondl'
        }
        r = requests.post(config.url + 'auth/register/v2', json=reg_data2)
        token2 = r.json().get('token')
        u_id2 = r.json().get('auth_user_id')
    
        # Create DM 1
        create_data = {
            'token': token2,
            'u_ids': [u_id2]
        }
    
        r = requests.post(config.url + 'dm/create/v1', json=create_data)
>       dm_id_1 = r.json().get('dm_id')

http_tests/message_share_http_test.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7e4bd54748>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>secondfsecondl is already a member of secondfsecondl, secondfsecondl</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7e4c5ae9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
________________________ test_valid_message_pin_channel ________________________

    def test_valid_message_pin_channel():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
        # sending message
        message = 'a'
        message_data = {'token': token, 'channel_id': ch_id, 'message': message}
        r = requests.post(config.url + 'message/send/v1', json=message_data)
>       message_id = r.json().get('message_id')

http_tests/message_unpin_http_test.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7e4bd54748>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7e4c5ae9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_________________________ test_unpin_message_unpinned __________________________

    def test_unpin_message_unpinned():
    
        requests.delete(config.url + '/clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + '/auth/register/v2', json=reg_data)
        token = r.json()['token']
    
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + '/channels/create/v2', json=ch_data)
        ch_id = r.json()['channel_id']
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        requests.post(config.url + '/channel/join/v2', json=join_data)
    
    
        message = 'a'
        message_data = {'token': token, 'channel_id': ch_id, 'message': message}
        r = requests.post(config.url + '/message/send/v1', json=message_data)
>       message_id = r.json()['message_id']

http_tests/message_unpin_http_test.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7e4bd54748>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7e4c5ae9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_____________________ test_pin_message_not_authorised_user _____________________

    def test_pin_message_not_authorised_user():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data = {
            'email': 'test@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
        # register a user
        reg_data = {
            'email': 'test123@gmail.com',
            'password': 'testpw123',
            'name_first': 'test_fname',
            'name_last': 'test_lname'
        }
    
        # acquire token and id of user
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token2 = r.json().get('token')
    
    
        # create a channel
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
        # Testing sending message
        message = 'a'
        message_data = {'token': token, 'channel_id': ch_id, 'message': message}
        r = requests.post(config.url + 'message/send/v1', json=message_data)
>       message_id = r.json().get('message_id')

http_tests/message_unpin_http_test.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7e4bd54748>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7e4c5ae9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
_____________________________ test_pin_message_dm ______________________________

    def test_pin_message_dm():
        requests.delete(config.url + 'clear/v1')
    
        #owner of dm/caller of dm_create
        reg_data = {
            'email': 'test_auth@gmail.com',
            'password': 'test_pw_auth',
            'name_first': 'testf',
            'name_last': 'testl'
        }
    
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
        auth_id = r.json().get('auth_user_id')
    
    
        # Create DM 1
        create_data = {
            'token': token,
            'u_ids': [auth_id]
        }
    
        r = requests.post(config.url + 'dm/create/v1', json=create_data)
>       dm_id_1 = r.json().get('dm_id')

http_tests/message_unpin_http_test.py:192: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/requests/models.py:900: in json
    return complexjson.loads(self.text, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/__init__.py:525: in loads
    return _default_decoder.decode(s)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:370: in decode
    obj, end = self.raw_decode(s)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <simplejson.decoder.JSONDecoder object at 0x7f7e4bd54748>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>testftestl is already a member of testftestl, testftestl</p>\n'
idx = 0, _w = <built-in method match of re.Pattern object at 0x7f7e4c5ae9f0>
_PY3 = True

    def raw_decode(self, s, idx=0, _w=WHITESPACE.match, _PY3=PY3):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
        Optionally, ``idx`` can be used to specify an offset in ``s`` where
        the JSON document begins.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        if idx < 0:
            # Ensure that raw_decode bails on negative indexes, the regex
            # would otherwise mask this behavior. #98
            raise JSONDecodeError('Expecting value', s, idx)
        if _PY3 and not isinstance(s, str):
            raise TypeError("Input string must be text, not bytes")
        # strip UTF-8 bom
        if len(s) > idx:
            ord0 = ord(s[idx])
            if ord0 == 0xfeff:
                idx += 1
            elif ord0 == 0xef and s[idx:idx + 3] == '\xef\xbb\xbf':
                idx += 3
>       return self.scan_once(s, idx=_w(s, idx).end())
E       simplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/simplejson/decoder.py:400: JSONDecodeError
______________________________ test_unreact_basic ______________________________

    def test_unreact_basic():
        requests.delete(config.url + 'clear/v1')
    
        reg_data = {
            'email': 'test_auth@gmail.com',
            'password': 'test_pw_auth',
            'name_first': 'testf',
            'name_last': 'testl'
        }
    
        r = requests.post(config.url + 'auth/register/v2', json=reg_data)
        token = r.json().get('token')
    
        ch_data = {
            'token': token,
            'name': 'test_ch',
            'is_public': True
        }
    
        # acquire channel id
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
        ch_id = r.json().get('channel_id')
    
        # join user to channel
        join_data = {
            'token': token,
            'channel_id': ch_id
        }
        r = requests.post(config.url + 'channel/join/v2', json=join_data)
    
        send_data = {
            'token': token,
            'channel_id': ch_id,
            'message': 'string',
        }
    
        r = requests.post(config.url + 'message/send/v1', json=send_data)
    
        react_data = {
            'token': token,
            'message_id': 0,
            'react_id': 1,
        }
    
        r = requests.post(config.url + 'message/react/v1', json=react_data)
    
        unreact_data = {
            'token': token,
            'message_id': 0,
            'react_id': 1,
        }
        r = requests.post(config.url + 'message/unreact/v1', json=unreact_data)
>       assert r.status_code == 200
E       assert 400 == 200
E         +400
E         -200

http_tests/message_unreact_http_test.py:61: AssertionError
___________________________ test_valid_user_profile ____________________________

    def test_valid_user_profile():
        requests.delete(config.url + 'clear/v1')
    
        data_1 = {
            'email': 'abc@def.com',
            'password': 'Password01!',
            'name_first': 'John',
            'name_last': 'Smith'
        }
    
        data_2 = {
            'email': 'abc@defgh.com',
            'password': 'Password01!',
            'name_first': 'mitchel',
            'name_last': 'johnson'
        }
    
        resp_register_1 = requests.post(config.url + 'auth/register/v2', json=data_1)
        token_1 = resp_register_1.json()['token']
        resp_register_2 = requests.post(config.url + 'auth/register/v2', json=data_2)
        u_id_2 = resp_register_2.json()['auth_user_id']
        data_3 = {
            'token': token_1,
            'u_id': u_id_2
        }
        print(data_3)
    
        resp_user_profile = requests.get(config.url + 'user/profile/v1', params=data_3)
>       assert resp_user_profile.status_code == 200
E       assert 404 == 200
E         +404
E         -200

http_tests/user_profile_http_test.py:41: AssertionError
----------------------------- Captured stdout call -----------------------------
{'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjIzMSwibG9naW5fdGltZSI6MTYxODk0MDE3Miwic2FsdCI6ImJlN2Q1ZDljLWM3YWYtNGFlMi04ZWIwLTk3YWFhNDM3ZGMwMCJ9.4M8pT5uHAZ_ba_j4Q8FEGjFCInSlgiPKp47jQ5TaMEM', 'u_id': 232}
______________________________ test_invalid_user _______________________________

    def test_invalid_user():
        requests.delete(config.url + 'clear/v1')
    
        data_1 = {
            'email': 'abc@def.com',
            'password': 'Password01!',
            'name_first': 'John',
            'name_last': 'Smith'
        }
    
        data_2 = {
            'email': 'abc@defgh.com',
            'password': 'Password01!',
            'name_first': 'mitchel',
            'name_last': 'johnson'
        }
    
        resp_register_1 = requests.post(config.url + 'auth/register/v2', json=data_1)
        token_1 = resp_register_1.json()['token']
        requests.post(config.url + 'auth/register/v2', json=data_2)
        u_id_2 = 4
        data_3 = {
            'token': token_1,
            'u_id': u_id_2
        }
    
        resp_user_profile = requests.get(config.url + 'user/profile/v1', params=data_3)
>       assert resp_user_profile.status_code == 400
E       assert 404 == 400
E         +404
E         -400

http_tests/user_profile_http_test.py:71: AssertionError
____________________________ test_valid_user_email _____________________________

    def test_valid_user_email():
        requests.delete(config.url + 'clear/v1')
    
        data_1 = {
            'email': 'abc@def.com',
            'password': 'Password01!',
            'name_first': 'John',
            'name_last': 'Smith'
        }
    
        resp_register_1 = requests.post(config.url + 'auth/register/v2', json=data_1)
        token_1 = resp_register_1.json().get('token')
        new_email = 'newemail@valid.com'
        data_2 = {
            'token': token_1,
            'email': new_email
        }
        #print(data_3)
    
        resp_user_profile = requests.put(config.url + 'user/profile/setemail/v1', json=data_2)
>       assert resp_user_profile.status_code == 200
E       assert 404 == 200
E         +404
E         -200

http_tests/user_profile_setemail_http_test.py:34: AssertionError
___________________________ test_invalid_user_email ____________________________

    def test_invalid_user_email():
        requests.delete(config.url + 'clear/v1')
    
        data_1 = {
            'email': 'abc@def.com',
            'password': 'Password01!',
            'name_first': 'John',
            'name_last': 'Smith'
        }
    
        resp_register_1 = requests.post(config.url + 'auth/register/v2', json=data_1)
        token_1 = resp_register_1.json().get('token')
        new_email = 'newinvalidemail.com'
        data_2 = {
            'token': token_1,
            'email': new_email
        }
        #print(data_3)
    
        resp_user_profile = requests.put(config.url + 'user/profile/setemail/v1', json=data_2)
>       assert resp_user_profile.status_code == 400
E       assert 404 == 400
E         +404
E         -400

http_tests/user_profile_setemail_http_test.py:56: AssertionError
_______________________ test_user_profile_setemail_used ________________________

    def test_user_profile_setemail_used():
        requests.delete(config.url + 'clear/v1')
    
        data_1 = {
            'email': 'abc@def.com',
            'password': 'Password01!',
            'name_first': 'John',
            'name_last': 'Smith'
        }
    
        data_2 = {
            'email': 'abc@defgh.com',
            'password': 'Password01!',
            'name_first': 'steve',
            'name_last': 'Smith'
        }
    
        resp_register_1 = requests.post(config.url + 'auth/register/v2', json=data_1)
        requests.post(config.url + 'auth/register/v2', json=data_2)
        token_1 = resp_register_1.json().get('token')
        #token_2 = resp_register_2.json().get('token')
        new_email = 'abc@defgh.com'
    
        data_3 = {
            'token': token_1,
            'email': new_email
        }
    
        resp_user_setemail = requests.put(config.url + 'user/profile/setemail/v1', json=data_3)
>       assert resp_user_setemail.status_code == 400
E       assert 404 == 400
E         +404
E         -400

http_tests/user_profile_setemail_http_test.py:87: AssertionError
_______________________ test_user_profile_sethandle_used _______________________

    def test_user_profile_sethandle_used():
        requests.delete(config.url + 'clear/v1')
        data_1 = {
            'email': 'abc@def.com',
            'password': 'Password01!',
            'name_first': 'John',
            'name_last': 'Smith'
        }
    
        data_2 = {
            'email': 'abc@defgh.com',
            'password': 'Password01!',
            'name_first': 'mitch',
            'name_last': 'john'
        }
    
        resp_register_1 = requests.post(config.url + 'auth/register/v2', json=data_1)
        resp_register_2 = requests.post(config.url + 'auth/register/v2', json=data_2)
        token_1 = resp_register_1.json().get('token')
        handle_used = resp_register_2.json().get('handle')
    
    
        data_3 = {
            'token': token_1,
            'handle_str': handle_used
        }
    
        resp_user_setemail = requests.put(config.url + 'user/profile/sethandle/v1', json=data_3)
>       assert resp_user_setemail.status_code == 400
E       assert 200 == 400
E         +200
E         -400

http_tests/user_profile_sethandle_http_test.py:64: AssertionError
_______________________ test_user_profile_setname_valid ________________________

    def test_user_profile_setname_valid():
        requests.delete(config.url + 'clear/v1')
        data_1 = {
            'email': 'abc@def.com',
            'password': 'Password01!',
            'name_first': 'John',
            'name_last': 'Smith'
        }
    
        resp_register_1 = requests.post(config.url + 'auth/register/v2', json=data_1)
        token_1 = resp_register_1.json().get('token')
        new_name_first = 'mitch'
        new_name_last = 'johnson'
    
        data_2 = {
            'token': token_1,
            'name_first': new_name_first,
            'name_last': new_name_last
        }
    
        resp_user_setname = requests.put(config.url + 'user/profile/setname/v1', json=data_2)
>       assert resp_user_setname.status_code == 200
E       assert 404 == 200
E         +404
E         -200

http_tests/user_profile_setname_http_test.py:33: AssertionError
__________________________ test_first_name_too_short ___________________________

    def test_first_name_too_short():
        requests.delete(config.url + 'clear/v1')
        data_1 = {
            'email': 'abc@def.com',
            'password': 'Password01!',
            'name_first': 'John',
            'name_last': 'Smith'
        }
    
        resp_register_1 = requests.post(config.url + 'auth/register/v2', json=data_1)
        token_1 = resp_register_1.json().get('token')
        new_name_first = 'm'
        new_name_last = 'johnson'
    
        data_2 = {
            'token': token_1,
            'name_first': new_name_first,
            'name_last': new_name_last
        }
    
        resp_user_setname = requests.put(config.url + 'user/profile/setname/v1', json=data_2)
>       assert resp_user_setname.status_code == 400
E       assert 404 == 400
E         +404
E         -400

http_tests/user_profile_setname_http_test.py:56: AssertionError
___________________________ test_first_name_too_long ___________________________

    def test_first_name_too_long():
        requests.delete(config.url + 'clear/v1')
        data_1 = {
            'email': 'abc@def.com',
            'password': 'Password01!',
            'name_first': 'John',
            'name_last': 'Smith'
        }
    
        resp_register_1 = requests.post(config.url + 'auth/register/v2', json=data_1)
        token_1 = resp_register_1.json().get('token')
        new_name_first = 'm' *52
        new_name_last = 'johnson'
    
        data_2 = {
            'token': token_1,
            'name_first': new_name_first,
            'name_last': new_name_last
        }
    
        resp_user_setname = requests.put(config.url + 'user/profile/setname/v1', json=data_2)
>       assert resp_user_setname.status_code == 400
E       assert 404 == 400
E         +404
E         -400

http_tests/user_profile_setname_http_test.py:79: AssertionError
___________________________ test_last_name_too_short ___________________________

    def test_last_name_too_short():
        requests.delete(config.url + 'clear/v1')
        data_1 = {
            'email': 'abc@def.com',
            'password': 'Password01!',
            'name_first': 'John',
            'name_last': 'Smith'
        }
    
        resp_register_1 = requests.post(config.url + 'auth/register/v2', json=data_1)
        token_1 = resp_register_1.json().get('token')
        new_name_first = 'mitch'
        new_name_last = 'j'
    
        data_2 = {
            'token': token_1,
            'name_first': new_name_first,
            'name_last': new_name_last
        }
    
        resp_user_setname = requests.put(config.url + 'user/profile/setname/v1', json=data_2)
>       assert resp_user_setname.status_code == 400
E       assert 404 == 400
E         +404
E         -400

http_tests/user_profile_setname_http_test.py:102: AssertionError
___________________________ test_last_name_too_long ____________________________

    def test_last_name_too_long():
        requests.delete(config.url + 'clear/v1')
        data_1 = {
            'email': 'abc@def.com',
            'password': 'Password01!',
            'name_first': 'John',
            'name_last': 'Smith'
        }
    
        resp_register_1 = requests.post(config.url + 'auth/register/v2', json=data_1)
        token_1 = resp_register_1.json().get('token')
        new_name_first = 'mitch'
        new_name_last = 'j' * 52
    
    
        data_2 = {
            'token': token_1,
            'name_first': new_name_first,
            'name_last': new_name_last
        }
    
        resp_user_setname = requests.put(config.url + 'user/profile/setname/v1', json=data_2)
>       assert resp_user_setname.status_code == 400
E       assert 404 == 400
E         +404
E         -400

http_tests/user_profile_setname_http_test.py:126: AssertionError
_________________________________ test_system __________________________________

    def test_system():
        requests.delete(config.url + 'clear/v1')
    
        # register a user
        reg_data1 = {
            'email': 'test1@gmail.com',
            'password': 'testpw1',
            'name_first': 'test_fname1',
            'name_last': 'test_lname1'
        }
        r = requests.post(config.url + 'auth/register/v2', json=reg_data1)
    
        # acquire token of user
        token1 = r.json().get('token')
    
        # create a channel
        ch_data = {
            'token': token1,
            'name': 'test_ch',
            'is_public': True
        }
        r = requests.post(config.url + 'channels/create/v2', json=ch_data)
    
        # acquire channel id
        ch_id = r.json().get('channel_id')
    
        # join user to channel
        join_data = {
            'token': token1,
            'channel_id': ch_id
        }
        requests.post(config.url + 'channel/join/v2', json=join_data)
    
        #create one user to pass in the list of users for dm create
        reg_data2 = {
            'email': 'test2@gmail.com',
            'password': 'testpw2',
            'name_first': 'test_fname2',
            'name_last': 'test_lname2'
        }
        r = requests.post(config.url + 'auth/register/v2', json=reg_data2)
    
        # get id of user2
        u_id2 = r.json().get('auth_user_id')
    
        create_data = {
            'token': token1,
            'u_ids': [u_id2]
        }
        r = requests.post(config.url + 'dm/create/v1', json=create_data)
    
        # create dm
        dm_id = r.json().get('dm_id')
    
        # send a message
        message_data = {'token': token1, 'dm_id': dm_id, 'message': 'hello'}
        r = requests.post(config.url + 'message/senddm/v1', json=message_data)
    
        stats_params = {
            'token': token1
        }
        r = requests.get(config.url + 'users/stats/v1', params=stats_params)
    
>       assert r.status_code == 200
E       assert 404 == 200
E         +404
E         -200

http_tests/users_stats_http_test.py:69: AssertionError
=========================== short test summary info ============================
FAILED http_tests/auth_logout_http_test.py::test_logout_valid - assert 404 ==...
FAILED http_tests/auth_register_http_test.py::test_auth_register_short_first_name
FAILED http_tests/channel_addowner_http_test.py::test_basic - assert 400 == 200
FAILED http_tests/channel_details_http_test.py::test_unauthorised_user - asse...
FAILED http_tests/channel_invite_http_test.py::test_invite_inviter_not_in_channel
FAILED http_tests/channel_join_http_test.py::test_join_channel - assert 400 =...
FAILED http_tests/channel_join_http_test.py::test_join_private - assert 400 =...
FAILED http_tests/channel_leave_http_test.py::test_basic - assert 400 == 200
FAILED http_tests/channel_leave_http_test.py::test_invalid_channel - assert 4...
FAILED http_tests/channel_leave_http_test.py::test_unauthorised_user - assert...
FAILED http_tests/channels_list_http_test.py::test_no_channels_list - Asserti...
FAILED http_tests/channels_list_http_test.py::test_two_channels_one_user_list
FAILED http_tests/channels_list_http_test.py::test_two_users_two_channels_list
FAILED http_tests/echo_http_test.py::test_echo - json.decoder.JSONDecodeError...
FAILED http_tests/message_edit_http_test.py::test_valid_message_edit - simple...
FAILED http_tests/message_edit_http_test.py::test_long_message_edit - simplej...
FAILED http_tests/message_edit_http_test.py::test_message_not_sent_by_same_user_message_edit
FAILED http_tests/message_pin_http_test.py::test_valid_message_pin_channel - ...
FAILED http_tests/message_pin_http_test.py::test_pin_message_pinned - simplej...
FAILED http_tests/message_pin_http_test.py::test_pin_message_not_authorised_user
FAILED http_tests/message_pin_http_test.py::test_pin_message_dm - simplejson....
FAILED http_tests/message_react_http_test.py::test_message_react_basic - asse...
FAILED http_tests/message_remove_http_test.py::test_message_remove_from_channel_invalid_message
FAILED http_tests/message_remove_http_test.py::test_message_remove_from_channel_not_sent_by_same_user
FAILED http_tests/message_remove_http_test.py::test_message_remove_from_channe
FAILED http_tests/message_remove_http_test.py::test_message_remove_from_dm - ...
FAILED http_tests/message_send_http_test.py::test_valid_message_send - assert...
FAILED http_tests/message_send_http_test.py::test_long_message_send - assert ...
FAILED http_tests/message_send_http_test.py::test_message_send_not_authorised_user
FAILED http_tests/message_senddm_v2_http_test.py::test_long_message_send - as...
FAILED http_tests/message_sendlater_http_test.py::test_message_sendlater_timeinpast
FAILED http_tests/message_sendlaterdm_http_test.py::test_message_sendlaterdm_timeinpast
FAILED http_tests/message_share_http_test.py::test_not_authorised_to_channel_message_share
FAILED http_tests/message_share_http_test.py::test_valid_message_share_to_channel
FAILED http_tests/message_share_http_test.py::test_message_share_to_dm - simp...
FAILED http_tests/message_share_http_test.py::test_message_share_to_dm_user_not_in_dm
FAILED http_tests/message_unpin_http_test.py::test_valid_message_pin_channel
FAILED http_tests/message_unpin_http_test.py::test_unpin_message_unpinned - s...
FAILED http_tests/message_unpin_http_test.py::test_pin_message_not_authorised_user
FAILED http_tests/message_unpin_http_test.py::test_pin_message_dm - simplejso...
FAILED http_tests/message_unreact_http_test.py::test_unreact_basic - assert 4...
FAILED http_tests/user_profile_http_test.py::test_valid_user_profile - assert...
FAILED http_tests/user_profile_http_test.py::test_invalid_user - assert 404 =...
FAILED http_tests/user_profile_setemail_http_test.py::test_valid_user_email
FAILED http_tests/user_profile_setemail_http_test.py::test_invalid_user_email
FAILED http_tests/user_profile_setemail_http_test.py::test_user_profile_setemail_used
FAILED http_tests/user_profile_sethandle_http_test.py::test_user_profile_sethandle_used
FAILED http_tests/user_profile_setname_http_test.py::test_user_profile_setname_valid
FAILED http_tests/user_profile_setname_http_test.py::test_first_name_too_short
FAILED http_tests/user_profile_setname_http_test.py::test_first_name_too_long
FAILED http_tests/user_profile_setname_http_test.py::test_last_name_too_short
FAILED http_tests/user_profile_setname_http_test.py::test_last_name_too_long
FAILED http_tests/users_stats_http_test.py::test_system - assert 404 == 200
======================== 53 failed, 77 passed in 6.20s =========================
