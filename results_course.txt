============================= test session starts ==============================
platform linux -- Python 3.7.3, pytest-6.1.0, py-1.9.0, pluggy-0.13.1
rootdir: /tmp_amd/ravel/export/ravel/1/hsmith/automark/tempstore, configfile: pytest.ini
plugins: hypothesis-5.36.1
collected 76 items

tests/echo_test.py FF                                                    [  2%]
tests/auth_tests/auth_login_test.py FF.                                  [  6%]
tests/auth_tests/auth_register_test.py ............................F...  [ 48%]
tests/channel_tests/channel_details_test.py FF.F                         [ 53%]
tests/channel_tests/channel_invite_test.py FFF.FF                        [ 61%]
tests/channel_tests/channel_join_test.py FFFF                            [ 67%]
tests/channel_tests/channel_messages_test.py FFFFF                       [ 73%]
tests/channels_tests/channels_create_test.py FF..F                       [ 80%]
tests/channels_tests/channels_list_test.py FFFFFFFFFF                    [ 93%]
tests/channels_tests/channels_listall_test.py FFFFF                      [100%]

=================================== FAILURES ===================================
__________________________________ test_echo ___________________________________

    def test_echo():
>       assert echo.echo("1") == "1", "1 == 1"
E       NameError: name 'echo' is not defined

tests/echo_test.py:7: NameError
_______________________________ test_echo_except _______________________________

    def test_echo_except():
        with pytest.raises(InputError):
>           assert echo.echo("echo")
E           NameError: name 'echo' is not defined

tests/echo_test.py:14: NameError
____________________________ test_successful_login _____________________________

user_woody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', name_first='sheriff', name_last='woody', u_id=0, token=0)

    @util.resets_workspace
    def test_successful_login(user_woody):
>       tok = auth_login_v1(user_woody.email, user_woody.password).popitem()[-1]
E       AttributeError: 'int' object has no attribute 'popitem'

tests/auth_tests/auth_login_test.py:12: AttributeError
____________________________ test_unregistered_user ____________________________

    @util.resets_workspace
    def test_unregistered_user():
        #  this test also covers 'invalid' emails, as an invalid email belongs to no user
        with pytest.raises(err.InputError):
>           auth_login_v1('bob.jane@example.com', 'qazwsx!!')

tests/auth_tests/auth_login_test.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

email = 'bob.jane@example.com', password = 'qazwsx!!'

    def auth_login_v1(email, password):
    
        if len(users) != 0:
            for user in users:
    
                if email_is_valid(email) != True:
                    raise InputError
    
                if (user['email'] == email and user['password'] == password):
                    u_id = user['u_id']
                elif (user['email'] != email):
                    print(email)
                    print(user['email'])
                    #print(u_id)
                    print(user['u_id'])
                    raise InputError
                elif (user["password"] != password):
                    raise InputError
    
>       return (u_id)
E       UnboundLocalError: local variable 'u_id' referenced before assignment

src/auth.py:34: UnboundLocalError
_____________________ test_auth_register_pass_names_short ______________________

    @util.resets_workspace
    def test_auth_register_pass_names_short():
>       assert is_valid(auth_register_v1(EMAIL, PASSWORD, "F", "L"))

tests/auth_tests/auth_register_test.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

email = 'valid.email@domain.com', password = 'aaaaaaaa', name_first = 'F'
name_last = 'L'

    def auth_register_v1(email, password, name_first, name_last):
        #setting handle
        handle = (name_first + name_last)
        handle = handle.lower()
    
        if len(users) != 0:
            for user in users:
                if user['email'] == email:
                    raise InputError
    
    
        n_users = 0
    
        for user in users:
    
            unique_suffix = str(n_users)
            handle_len = len(handle)
    
            if user['handle'] == handle:
    
                if handle_len > 20:
                    handle = (name_first + name_last)[:20] + unique_suffix
                    '''
                    if handle == user['handle']:
                        handle = handle + unique_suffix
                    '''
                elif handle_len <= 20:
                    handle = name_first + name_last + unique_suffix
                    #print(n_users)
                    '''
                    if handle == user['handle']:
                        handle = handle + unique_suffix
                    '''
            n_users += 1
    
        if email_is_valid(email) != True:
                raise InputError
        #checking len first and last name less than 50 and more than 1
        if len(name_first) > 50 or  len(name_first) <= 1 or len(name_last) > 50 or len(name_last) <= 1:
>           raise InputError
E           src.error.InputError

src/auth.py:76: InputError
____________________________ test_member_successful ____________________________

woodys_public_toybox = Channel(name='woodys toybox', is_public=True, channel_id=0, owner_members=[0], all_members=[])
user_woody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', name_first='sheriff', name_last='woody', u_id=0, token=0)
user_buzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', name_first='buzz', name_last='lightyear', u_id=1, token=1)

    @util.resets_workspace
    def test_member_successful(woodys_public_toybox, user_woody, user_buzz):
>       channel_join_v1(user_buzz.token, woodys_public_toybox.channel_id)

tests/channel_tests/channel_details_test.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/channel.py:83: in channel_join_v1
    if test_user_is_invalid(auth_user_id):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

u_id = 1

    def test_user_is_invalid(u_id):
        # if users list is empty, then obviously invalid
        if len(users) == 0:
            return True
    
        # searches for the key value pair of 'u_id': u_id
        # if found, then user exists
        for user in users:
>           key, value = 'u_id', u_id['auth_user_id']
E           TypeError: 'int' object is not subscriptable

src/channel.py:138: TypeError
________________________ test_non_member_not_successful ________________________

woodys_public_toybox = Channel(name='woodys toybox', is_public=True, channel_id=0, owner_members=[0], all_members=[])
user_zerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', name_first='lord', name_last='zerg', u_id=1, token=1)

    @util.resets_workspace
    def test_non_member_not_successful(woodys_public_toybox, user_zerg):
        with pytest.raises(err.AccessError):
>           channel_details_v1(user_zerg.token, woodys_public_toybox.channel_id)

tests/channel_tests/channel_details_test.py:35: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/channel.py:32: in channel_details_v1
    if test_channel_is_invalid(channel_id):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

channel_id = 0

    def test_channel_is_invalid(channel_id):
        # if channels list is empty, then obviously invalid
        if len(channels) == 0:
            return True
        # searches for the key value pair of 'id': channel_id
        # if found, then channel exists
        for ch in channels:
>           key, value = 'id', channel_id['id']
E           TypeError: 'int' object is not subscriptable

src/channel.py:122: TypeError
______________________________ test_invalid_token ______________________________

woodys_public_toybox = Channel(name='woodys toybox', is_public=True, channel_id=0, owner_members=[0], all_members=[])

    @util.resets_workspace
    def test_invalid_token(woodys_public_toybox):
        with pytest.raises(err.AccessError):
>           channel_details_v1(None, woodys_public_toybox.channel_id)

tests/channel_tests/channel_details_test.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/channel.py:32: in channel_details_v1
    if test_channel_is_invalid(channel_id):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

channel_id = 0

    def test_channel_is_invalid(channel_id):
        # if channels list is empty, then obviously invalid
        if len(channels) == 0:
            return True
        # searches for the key value pair of 'id': channel_id
        # if found, then channel exists
        for ch in channels:
>           key, value = 'id', channel_id['id']
E           TypeError: 'int' object is not subscriptable

src/channel.py:122: TypeError
___________________________ test_invite_global_owner ___________________________

user_woody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', name_first='sheriff', name_last='woody', u_id=0, token=0)
user_zerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', name_first='lord', name_last='zerg', u_id=1, token=1)
zergs_private_lair = Channel(name='zergs lair', is_public=False, channel_id=0, owner_members=[1], all_members=[])

    @util.resets_workspace
    def test_invite_global_owner(user_woody, user_zerg, zergs_private_lair):
>       channel_invite_v1(user_zerg.token, zergs_private_lair.channel_id, user_woody.u_id)

tests/channel_tests/channel_invite_test.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/channel.py:6: in channel_invite_v1
    if test_channel_is_invalid(channel_id):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

channel_id = 0

    def test_channel_is_invalid(channel_id):
        # if channels list is empty, then obviously invalid
        if len(channels) == 0:
            return True
        # searches for the key value pair of 'id': channel_id
        # if found, then channel exists
        for ch in channels:
>           key, value = 'id', channel_id['id']
E           TypeError: 'int' object is not subscriptable

src/channel.py:122: TypeError
__________________________ test_invite_global_member ___________________________

user_woody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', name_first='sheriff', name_last='woody', u_id=0, token=0)
user_buzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', name_first='buzz', name_last='lightyear', u_id=1, token=1)
woodys_public_toybox = Channel(name='woodys toybox', is_public=True, channel_id=0, owner_members=[0], all_members=[])

    @util.resets_workspace
    def test_invite_global_member(user_woody, user_buzz, woodys_public_toybox):
>       channel_invite_v1(user_woody.token, woodys_public_toybox.channel_id, user_buzz.u_id)

tests/channel_tests/channel_invite_test.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/channel.py:6: in channel_invite_v1
    if test_channel_is_invalid(channel_id):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

channel_id = 0

    def test_channel_is_invalid(channel_id):
        # if channels list is empty, then obviously invalid
        if len(channels) == 0:
            return True
        # searches for the key value pair of 'id': channel_id
        # if found, then channel exists
        for ch in channels:
>           key, value = 'id', channel_id['id']
E           TypeError: 'int' object is not subscriptable

src/channel.py:122: TypeError
___________________ test_invitation_from_non_channel_member ____________________

user_woody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', name_first='sheriff', name_last='woody', u_id=0, token=0)
user_buzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', name_first='buzz', name_last='lightyear', u_id=1, token=1)
zergs_private_lair = Channel(name='zergs lair', is_public=False, channel_id=0, owner_members=[2], all_members=[])

    @util.resets_workspace
    def test_invitation_from_non_channel_member(user_woody, user_buzz, zergs_private_lair):
        with pytest.raises(err.AccessError):
>           channel_invite_v1(user_woody, zergs_private_lair.channel_id, user_buzz.u_id)

tests/channel_tests/channel_invite_test.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/channel.py:6: in channel_invite_v1
    if test_channel_is_invalid(channel_id):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

channel_id = 0

    def test_channel_is_invalid(channel_id):
        # if channels list is empty, then obviously invalid
        if len(channels) == 0:
            return True
        # searches for the key value pair of 'id': channel_id
        # if found, then channel exists
        for ch in channels:
>           key, value = 'id', channel_id['id']
E           TypeError: 'int' object is not subscriptable

src/channel.py:122: TypeError
______________________________ test_u_id_invalid _______________________________

user_woody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', name_first='sheriff', name_last='woody', u_id=0, token=0)
woodys_public_toybox = Channel(name='woodys toybox', is_public=True, channel_id=0, owner_members=[0], all_members=[])

    @util.resets_workspace
    def test_u_id_invalid(user_woody, woodys_public_toybox):
        with pytest.raises(err.InputError):
            # noinspection PyTypeChecker
>           channel_invite_v1(user_woody.token, woodys_public_toybox.channel_id, None)

tests/channel_tests/channel_invite_test.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/channel.py:6: in channel_invite_v1
    if test_channel_is_invalid(channel_id):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

channel_id = 0

    def test_channel_is_invalid(channel_id):
        # if channels list is empty, then obviously invalid
        if len(channels) == 0:
            return True
        # searches for the key value pair of 'id': channel_id
        # if found, then channel exists
        for ch in channels:
>           key, value = 'id', channel_id['id']
E           TypeError: 'int' object is not subscriptable

src/channel.py:122: TypeError
____________________________ test_invalidated_token ____________________________

woodys_public_toybox = Channel(name='woodys toybox', is_public=True, channel_id=0, owner_members=[0], all_members=[])
user_buzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', name_first='buzz', name_last='lightyear', u_id=1, token=1)

    @util.resets_workspace
    def test_invalidated_token(woodys_public_toybox, user_buzz):
        with pytest.raises(err.AccessError):
>           channel_invite_v1(None, woodys_public_toybox.channel_id, user_buzz.u_id)

tests/channel_tests/channel_invite_test.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/channel.py:6: in channel_invite_v1
    if test_channel_is_invalid(channel_id):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

channel_id = 0

    def test_channel_is_invalid(channel_id):
        # if channels list is empty, then obviously invalid
        if len(channels) == 0:
            return True
        # searches for the key value pair of 'id': channel_id
        # if found, then channel exists
        for ch in channels:
>           key, value = 'id', channel_id['id']
E           TypeError: 'int' object is not subscriptable

src/channel.py:122: TypeError
____________________ test_global_owner_join_channel_private ____________________

user_woody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', name_first='sheriff', name_last='woody', u_id=0, token=0)
zergs_private_lair = Channel(name='zergs lair', is_public=False, channel_id=0, owner_members=[1], all_members=[])

    @util.resets_workspace
    def test_global_owner_join_channel_private(user_woody, zergs_private_lair):
>       channel_join_v1(user_woody.token, zergs_private_lair.channel_id)

tests/channel_tests/channel_join_test.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/channel.py:83: in channel_join_v1
    if test_user_is_invalid(auth_user_id):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

u_id = 0

    def test_user_is_invalid(u_id):
        # if users list is empty, then obviously invalid
        if len(users) == 0:
            return True
    
        # searches for the key value pair of 'u_id': u_id
        # if found, then user exists
        for user in users:
>           key, value = 'u_id', u_id['auth_user_id']
E           TypeError: 'int' object is not subscriptable

src/channel.py:138: TypeError
________________________ test_global_member_join_public ________________________

woodys_public_toybox = Channel(name='woodys toybox', is_public=True, channel_id=0, owner_members=[0], all_members=[])
user_buzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', name_first='buzz', name_last='lightyear', u_id=1, token=1)

    @util.resets_workspace
    def test_global_member_join_public(woodys_public_toybox, user_buzz):
>       channel_join_v1(user_buzz.token, woodys_public_toybox.channel_id)

tests/channel_tests/channel_join_test.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/channel.py:83: in channel_join_v1
    if test_user_is_invalid(auth_user_id):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

u_id = 1

    def test_user_is_invalid(u_id):
        # if users list is empty, then obviously invalid
        if len(users) == 0:
            return True
    
        # searches for the key value pair of 'u_id': u_id
        # if found, then user exists
        for user in users:
>           key, value = 'u_id', u_id['auth_user_id']
E           TypeError: 'int' object is not subscriptable

src/channel.py:138: TypeError
_________________________ test_join_invalid_channel_id _________________________

user_woody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', name_first='sheriff', name_last='woody', u_id=0, token=0)

    @util.resets_workspace
    def test_join_invalid_channel_id(user_woody):
        with pytest.raises(err.InputError):
            # noinspection PyTypeChecker
>           channel_join_v1(user_woody.token, 'hi')

tests/channel_tests/channel_join_test.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/channel.py:83: in channel_join_v1
    if test_user_is_invalid(auth_user_id):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

u_id = 0

    def test_user_is_invalid(u_id):
        # if users list is empty, then obviously invalid
        if len(users) == 0:
            return True
    
        # searches for the key value pair of 'u_id': u_id
        # if found, then user exists
        for user in users:
>           key, value = 'u_id', u_id['auth_user_id']
E           TypeError: 'int' object is not subscriptable

src/channel.py:138: TypeError
____________________________ test_invalidated_token ____________________________

woodys_public_toybox = Channel(name='woodys toybox', is_public=True, channel_id=0, owner_members=[0], all_members=[])

    @util.resets_workspace
    def test_invalidated_token(woodys_public_toybox):
        with pytest.raises(err.AccessError):
>           channel_join_v1(None, woodys_public_toybox.channel_id)

tests/channel_tests/channel_join_test.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/channel.py:83: in channel_join_v1
    if test_user_is_invalid(auth_user_id):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

u_id = None

    def test_user_is_invalid(u_id):
        # if users list is empty, then obviously invalid
        if len(users) == 0:
            return True
    
        # searches for the key value pair of 'u_id': u_id
        # if found, then user exists
        for user in users:
>           key, value = 'u_id', u_id['auth_user_id']
E           TypeError: 'NoneType' object is not subscriptable

src/channel.py:138: TypeError
_______________________________ test_no_messages _______________________________

woodys_public_toybox = Channel(name='woodys toybox', is_public=True, channel_id=0, owner_members=[0], all_members=[])
user_woody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', name_first='sheriff', name_last='woody', u_id=0, token=0)

    @util.resets_workspace
    def test_no_messages(woodys_public_toybox, user_woody):
>       ch_msgs = channel_messages_v1(user_woody.token, woodys_public_toybox.channel_id, 0)

tests/channel_tests/channel_messages_test.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/channel.py:50: in channel_messages_v1
    if test_user_is_invalid(auth_user_id):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

u_id = 0

    def test_user_is_invalid(u_id):
        # if users list is empty, then obviously invalid
        if len(users) == 0:
            return True
    
        # searches for the key value pair of 'u_id': u_id
        # if found, then user exists
        for user in users:
>           key, value = 'u_id', u_id['auth_user_id']
E           TypeError: 'int' object is not subscriptable

src/channel.py:138: TypeError
_____________ test_input_error_when_start_greate_than_message_num ______________

woodys_public_toybox = Channel(name='woodys toybox', is_public=True, channel_id=0, owner_members=[0], all_members=[])
user_woody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', name_first='sheriff', name_last='woody', u_id=0, token=0)

    @util.resets_workspace
    def test_input_error_when_start_greate_than_message_num(woodys_public_toybox, user_woody):
        with pytest.raises(err.InputError):
>           channel_messages_v1(user_woody.token, woodys_public_toybox.channel_id, 21389429)

tests/channel_tests/channel_messages_test.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/channel.py:50: in channel_messages_v1
    if test_user_is_invalid(auth_user_id):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

u_id = 0

    def test_user_is_invalid(u_id):
        # if users list is empty, then obviously invalid
        if len(users) == 0:
            return True
    
        # searches for the key value pair of 'u_id': u_id
        # if found, then user exists
        for user in users:
>           key, value = 'u_id', u_id['auth_user_id']
E           TypeError: 'int' object is not subscriptable

src/channel.py:138: TypeError
__________________ test_access_error_when_user_is_non_member ___________________

woodys_public_toybox = Channel(name='woodys toybox', is_public=True, channel_id=0, owner_members=[0], all_members=[])
user_zerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', name_first='lord', name_last='zerg', u_id=1, token=1)

    @util.resets_workspace
    def test_access_error_when_user_is_non_member(woodys_public_toybox, user_zerg):
        with pytest.raises(err.AccessError):
>           channel_messages_v1(user_zerg.token, woodys_public_toybox.channel_id, 0)

tests/channel_tests/channel_messages_test.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/channel.py:50: in channel_messages_v1
    if test_user_is_invalid(auth_user_id):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

u_id = 1

    def test_user_is_invalid(u_id):
        # if users list is empty, then obviously invalid
        if len(users) == 0:
            return True
    
        # searches for the key value pair of 'u_id': u_id
        # if found, then user exists
        for user in users:
>           key, value = 'u_id', u_id['auth_user_id']
E           TypeError: 'int' object is not subscriptable

src/channel.py:138: TypeError
___________________ test_input_error_when_channel_id_invalid ___________________

user_woody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', name_first='sheriff', name_last='woody', u_id=0, token=0)

    @util.resets_workspace
    def test_input_error_when_channel_id_invalid(user_woody):
        with pytest.raises(err.InputError):
>           channel_messages_v1(user_woody.token, None, 0)

tests/channel_tests/channel_messages_test.py:35: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/channel.py:50: in channel_messages_v1
    if test_user_is_invalid(auth_user_id):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

u_id = 0

    def test_user_is_invalid(u_id):
        # if users list is empty, then obviously invalid
        if len(users) == 0:
            return True
    
        # searches for the key value pair of 'u_id': u_id
        # if found, then user exists
        for user in users:
>           key, value = 'u_id', u_id['auth_user_id']
E           TypeError: 'int' object is not subscriptable

src/channel.py:138: TypeError
__________________ test_access_error_when_invalid_token_given __________________

woodys_public_toybox = Channel(name='woodys toybox', is_public=True, channel_id=0, owner_members=[0], all_members=[])

    @util.resets_workspace
    def test_access_error_when_invalid_token_given(woodys_public_toybox):
        with pytest.raises(err.AccessError):
>           channel_messages_v1(None, woodys_public_toybox.channel_id, 0)

tests/channel_tests/channel_messages_test.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/channel.py:50: in channel_messages_v1
    if test_user_is_invalid(auth_user_id):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

u_id = None

    def test_user_is_invalid(u_id):
        # if users list is empty, then obviously invalid
        if len(users) == 0:
            return True
    
        # searches for the key value pair of 'u_id': u_id
        # if found, then user exists
        for user in users:
>           key, value = 'u_id', u_id['auth_user_id']
E           TypeError: 'NoneType' object is not subscriptable

src/channel.py:138: TypeError
_____________________ test_create_channel[True-andys room] _____________________

name = 'andys room', is_public = True
user_zerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', name_first='lord', name_last='zerg', u_id=0, token=0)
user_woody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', name_first='sheriff', name_last='woody', u_id=1, token=1)

    @pytest.mark.parametrize('name', ['andys room'])
    @pytest.mark.parametrize('is_public', [True, False])
    @util.resets_workspace
    def test_create_channel(name, is_public, user_zerg, user_woody):
>       ch_id = channels_create_v1(user_zerg.token, name, is_public)['channel_id']
E       KeyError: 'channel_id'

tests/channels_tests/channels_create_test.py:16: KeyError
____________________ test_create_channel[False-andys room] _____________________

name = 'andys room', is_public = False
user_zerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', name_first='lord', name_last='zerg', u_id=0, token=0)
user_woody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', name_first='sheriff', name_last='woody', u_id=1, token=1)

    @pytest.mark.parametrize('name', ['andys room'])
    @pytest.mark.parametrize('is_public', [True, False])
    @util.resets_workspace
    def test_create_channel(name, is_public, user_zerg, user_woody):
>       ch_id = channels_create_v1(user_zerg.token, name, is_public)['channel_id']
E       KeyError: 'channel_id'

tests/channels_tests/channels_create_test.py:16: KeyError
____________________________ test_invalidated_token ____________________________

user_woody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', name_first='sheriff', name_last='woody', u_id=0, token=0)

    @util.resets_workspace
    def test_invalidated_token(user_woody):
        # sadly a dirty hack is knowing None is not an int and thus should be invalid
        # TODO: change when auth_logout is available again
        with pytest.raises(err.AccessError):
>           channels_create_v1(None, 'literally anything', True)
E           Failed: DID NOT RAISE <class 'src.error.AccessError'>

tests/channels_tests/channels_create_test.py:41: Failed
______________________ test_when_member_is_in_no_channels ______________________

user_woody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', name_first='sheriff', name_last='woody', u_id=0, token=0)

    @util.resets_workspace
    def test_when_member_is_in_no_channels(user_woody):
>       assert channels_list_v1(user_woody.token)['channels'] == []
E       AssertionError: assert [{'channel_id...'My Channel'}] == []
E         Left contains one more item: {'channel_id': 1, 'name': 'My Channel'}
E         Use -v to get the full diff

tests/channels_tests/channels_list_test.py:13: AssertionError
___________________ test_channel_owner_in_channel[True-andy] ___________________

name = 'andy', is_public = True
user_woody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', name_first='sheriff', name_last='woody', u_id=0, token=0)

    @pytest.mark.parametrize('name', ['andy'])
    @pytest.mark.parametrize('is_public', [True, False])
    @util.resets_workspace
    def test_channel_owner_in_channel(name, is_public, user_woody):
>       ch = channels_create_v1(user_woody.token, name, is_public)['channel_id']
E       KeyError: 'channel_id'

tests/channels_tests/channels_list_test.py:20: KeyError
__________________ test_channel_owner_in_channel[False-andy] ___________________

name = 'andy', is_public = False
user_woody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', name_first='sheriff', name_last='woody', u_id=0, token=0)

    @pytest.mark.parametrize('name', ['andy'])
    @pytest.mark.parametrize('is_public', [True, False])
    @util.resets_workspace
    def test_channel_owner_in_channel(name, is_public, user_woody):
>       ch = channels_create_v1(user_woody.token, name, is_public)['channel_id']
E       KeyError: 'channel_id'

tests/channels_tests/channels_list_test.py:20: KeyError
__________________ test_channel_member_in_channel[True-andy] ___________________

name = 'andy', is_public = True
user_woody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', name_first='sheriff', name_last='woody', u_id=0, token=0)
user_zerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', name_first='lord', name_last='zerg', u_id=1, token=1)

    @pytest.mark.parametrize('name', ['andy'])
    @pytest.mark.parametrize('is_public', [True, False])
    @util.resets_workspace
    def test_channel_member_in_channel(name, is_public, user_woody, user_zerg):
>       ch = channels_create_v1(user_woody.token, name, is_public)['channel_id']
E       KeyError: 'channel_id'

tests/channels_tests/channels_list_test.py:31: KeyError
__________________ test_channel_member_in_channel[False-andy] __________________

name = 'andy', is_public = False
user_woody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', name_first='sheriff', name_last='woody', u_id=0, token=0)
user_zerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', name_first='lord', name_last='zerg', u_id=1, token=1)

    @pytest.mark.parametrize('name', ['andy'])
    @pytest.mark.parametrize('is_public', [True, False])
    @util.resets_workspace
    def test_channel_member_in_channel(name, is_public, user_woody, user_zerg):
>       ch = channels_create_v1(user_woody.token, name, is_public)['channel_id']
E       KeyError: 'channel_id'

tests/channels_tests/channels_list_test.py:31: KeyError
_____________ test_user_in_multiple_channels[False-True-ZERG-andy] _____________

name1 = 'andy', name2 = 'ZERG', is_public1 = True, is_public2 = False
user_woody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', name_first='sheriff', name_last='woody', u_id=0, token=0)

    @pytest.mark.parametrize('name1', ['andy'])
    @pytest.mark.parametrize('name2', ['ZERG'])
    @pytest.mark.parametrize('is_public1', [True, False])
    @pytest.mark.parametrize('is_public2', [False, True])
    @util.resets_workspace
    def test_user_in_multiple_channels(name1, name2, is_public1, is_public2, user_woody):
>       ch_1 = channels_create_v1(user_woody.token, name1, is_public1)['channel_id']
E       KeyError: 'channel_id'

tests/channels_tests/channels_list_test.py:46: KeyError
____________ test_user_in_multiple_channels[False-False-ZERG-andy] _____________

name1 = 'andy', name2 = 'ZERG', is_public1 = False, is_public2 = False
user_woody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', name_first='sheriff', name_last='woody', u_id=0, token=0)

    @pytest.mark.parametrize('name1', ['andy'])
    @pytest.mark.parametrize('name2', ['ZERG'])
    @pytest.mark.parametrize('is_public1', [True, False])
    @pytest.mark.parametrize('is_public2', [False, True])
    @util.resets_workspace
    def test_user_in_multiple_channels(name1, name2, is_public1, is_public2, user_woody):
>       ch_1 = channels_create_v1(user_woody.token, name1, is_public1)['channel_id']
E       KeyError: 'channel_id'

tests/channels_tests/channels_list_test.py:46: KeyError
_____________ test_user_in_multiple_channels[True-True-ZERG-andy] ______________

name1 = 'andy', name2 = 'ZERG', is_public1 = True, is_public2 = True
user_woody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', name_first='sheriff', name_last='woody', u_id=0, token=0)

    @pytest.mark.parametrize('name1', ['andy'])
    @pytest.mark.parametrize('name2', ['ZERG'])
    @pytest.mark.parametrize('is_public1', [True, False])
    @pytest.mark.parametrize('is_public2', [False, True])
    @util.resets_workspace
    def test_user_in_multiple_channels(name1, name2, is_public1, is_public2, user_woody):
>       ch_1 = channels_create_v1(user_woody.token, name1, is_public1)['channel_id']
E       KeyError: 'channel_id'

tests/channels_tests/channels_list_test.py:46: KeyError
_____________ test_user_in_multiple_channels[True-False-ZERG-andy] _____________

name1 = 'andy', name2 = 'ZERG', is_public1 = False, is_public2 = True
user_woody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', name_first='sheriff', name_last='woody', u_id=0, token=0)

    @pytest.mark.parametrize('name1', ['andy'])
    @pytest.mark.parametrize('name2', ['ZERG'])
    @pytest.mark.parametrize('is_public1', [True, False])
    @pytest.mark.parametrize('is_public2', [False, True])
    @util.resets_workspace
    def test_user_in_multiple_channels(name1, name2, is_public1, is_public2, user_woody):
>       ch_1 = channels_create_v1(user_woody.token, name1, is_public1)['channel_id']
E       KeyError: 'channel_id'

tests/channels_tests/channels_list_test.py:46: KeyError
____________________________ test_invalidated_token ____________________________

woodys_public_toybox = Channel(name='woodys toybox', is_public=True, channel_id=0, owner_members=[0], all_members=[])

    @util.resets_workspace
    def test_invalidated_token(woodys_public_toybox):
        with pytest.raises(err.AccessError):
            # a dirty hack
            # TODO: fix this for when auth_logout is available again
>           channels_list_v1(None)
E           Failed: DID NOT RAISE <class 'src.error.AccessError'>

tests/channels_tests/channels_list_test.py:59: Failed
____________________________ test_when_no_channels _____________________________

user_woody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', name_first='sheriff', name_last='woody', u_id=0, token=0)

    @util.resets_workspace
    def test_when_no_channels(user_woody):
>       assert channels_listall_v1(user_woody.token)['channels'] == []
E       AssertionError: assert [{'channel_id...'My Channel'}] == []
E         Left contains one more item: {'channel_id': 1, 'name': 'My Channel'}
E         Use -v to get the full diff

tests/channels_tests/channels_listall_test.py:12: AssertionError
_____________________ test_when_one_channel_exists_private _____________________

user_woody = User(email='sheriff.woody@andysroom.com', password='qazwsx!!', name_first='sheriff', name_last='woody', u_id=0, token=0)
zergs_private_lair = Channel(name='zergs lair', is_public=False, channel_id=0, owner_members=[1], all_members=[])

    @util.resets_workspace
    def test_when_one_channel_exists_private(user_woody, zergs_private_lair):
        channel_detail = {'channel_id': zergs_private_lair.channel_id, 'name': zergs_private_lair.name}
    
>       assert channel_detail in channels_listall_v1(user_woody.token)['channels']
E       AssertionError: assert {'channel_id': 0, 'name': 'zergs lair'} in [{'channel_id': 1, 'name': 'My Channel'}]

tests/channels_tests/channels_listall_test.py:19: AssertionError
_____________________ test_when_one_channel_exists_public ______________________

user_zerg = User(email='zerg.thedestroyer@zergworld.com', password='!!qazwsx', name_first='lord', name_last='zerg', u_id=0, token=0)
woodys_public_toybox = Channel(name='woodys toybox', is_public=True, channel_id=0, owner_members=[1], all_members=[])

    @util.resets_workspace
    def test_when_one_channel_exists_public(user_zerg, woodys_public_toybox):
        channel_detail = {'channel_id': woodys_public_toybox.channel_id, 'name': woodys_public_toybox.name}
    
>       assert channel_detail in channels_listall_v1(user_zerg.token)['channels']
E       AssertionError: assert {'channel_id': 0, 'name': 'woodys toybox'} in [{'channel_id': 1, 'name': 'My Channel'}]

tests/channels_tests/channels_listall_test.py:26: AssertionError
______________________ test_when_multiple_channels_exist _______________________

woodys_public_toybox = Channel(name='woodys toybox', is_public=True, channel_id=0, owner_members=[0], all_members=[])
zergs_private_lair = Channel(name='zergs lair', is_public=False, channel_id=1, owner_members=[1], all_members=[])
user_buzz = User(email='buzz.lightyear@starcommand.com', password='qazwsx@@', name_first='buzz', name_last='lightyear', u_id=2, token=2)

    @util.resets_workspace
    def test_when_multiple_channels_exist(woodys_public_toybox, zergs_private_lair, user_buzz):
        expected_chs = [
            {'channel_id': woodys_public_toybox.channel_id, 'name': woodys_public_toybox.name},
            {'channel_id': zergs_private_lair.channel_id, 'name': zergs_private_lair.name}
        ]
    
        chs = channels.channels_listall_v1(user_buzz.token)['channels']
    
>       assert sorted(chs, key=lambda d: d['channel_id']) == sorted(expected_chs, key=lambda d: d['channel_id'])
E       AssertionError: assert [{'channel_id...'My Channel'}] == [{'channel_id...'zergs lair'}]
E         At index 0 diff: {'channel_id': 1, 'name': 'My Channel'} != {'channel_id': 0, 'name': 'woodys toybox'}
E         Right contains one more item: {'channel_id': 1, 'name': 'zergs lair'}
E         Use -v to get the full diff

tests/channels_tests/channels_listall_test.py:38: AssertionError
____________________________ test_invalidated_token ____________________________

woodys_public_toybox = Channel(name='woodys toybox', is_public=True, channel_id=0, owner_members=[0], all_members=[])

    @util.resets_workspace
    def test_invalidated_token(woodys_public_toybox):
        with pytest.raises(err.AccessError):
            # a dirty hack
            # TODO: fix this for when auth_logout is available again
>           channels_listall_v1(None)
E           Failed: DID NOT RAISE <class 'src.error.AccessError'>

tests/channels_tests/channels_listall_test.py:46: Failed
=========================== short test summary info ============================
FAILED tests/echo_test.py::test_echo - NameError: name 'echo' is not defined
FAILED tests/echo_test.py::test_echo_except - NameError: name 'echo' is not d...
FAILED tests/auth_tests/auth_login_test.py::test_successful_login - Attribute...
FAILED tests/auth_tests/auth_login_test.py::test_unregistered_user - UnboundL...
FAILED tests/auth_tests/auth_register_test.py::test_auth_register_pass_names_short
FAILED tests/channel_tests/channel_details_test.py::test_member_successful - ...
FAILED tests/channel_tests/channel_details_test.py::test_non_member_not_successful
FAILED tests/channel_tests/channel_details_test.py::test_invalid_token - Type...
FAILED tests/channel_tests/channel_invite_test.py::test_invite_global_owner
FAILED tests/channel_tests/channel_invite_test.py::test_invite_global_member
FAILED tests/channel_tests/channel_invite_test.py::test_invitation_from_non_channel_member
FAILED tests/channel_tests/channel_invite_test.py::test_u_id_invalid - TypeEr...
FAILED tests/channel_tests/channel_invite_test.py::test_invalidated_token - T...
FAILED tests/channel_tests/channel_join_test.py::test_global_owner_join_channel_private
FAILED tests/channel_tests/channel_join_test.py::test_global_member_join_public
FAILED tests/channel_tests/channel_join_test.py::test_join_invalid_channel_id
FAILED tests/channel_tests/channel_join_test.py::test_invalidated_token - Typ...
FAILED tests/channel_tests/channel_messages_test.py::test_no_messages - TypeE...
FAILED tests/channel_tests/channel_messages_test.py::test_input_error_when_start_greate_than_message_num
FAILED tests/channel_tests/channel_messages_test.py::test_access_error_when_user_is_non_member
FAILED tests/channel_tests/channel_messages_test.py::test_input_error_when_channel_id_invalid
FAILED tests/channel_tests/channel_messages_test.py::test_access_error_when_invalid_token_given
FAILED tests/channels_tests/channels_create_test.py::test_create_channel[True-andys room]
FAILED tests/channels_tests/channels_create_test.py::test_create_channel[False-andys room]
FAILED tests/channels_tests/channels_create_test.py::test_invalidated_token
FAILED tests/channels_tests/channels_list_test.py::test_when_member_is_in_no_channels
FAILED tests/channels_tests/channels_list_test.py::test_channel_owner_in_channel[True-andy]
FAILED tests/channels_tests/channels_list_test.py::test_channel_owner_in_channel[False-andy]
FAILED tests/channels_tests/channels_list_test.py::test_channel_member_in_channel[True-andy]
FAILED tests/channels_tests/channels_list_test.py::test_channel_member_in_channel[False-andy]
FAILED tests/channels_tests/channels_list_test.py::test_user_in_multiple_channels[False-True-ZERG-andy]
FAILED tests/channels_tests/channels_list_test.py::test_user_in_multiple_channels[False-False-ZERG-andy]
FAILED tests/channels_tests/channels_list_test.py::test_user_in_multiple_channels[True-True-ZERG-andy]
FAILED tests/channels_tests/channels_list_test.py::test_user_in_multiple_channels[True-False-ZERG-andy]
FAILED tests/channels_tests/channels_list_test.py::test_invalidated_token - F...
FAILED tests/channels_tests/channels_listall_test.py::test_when_no_channels
FAILED tests/channels_tests/channels_listall_test.py::test_when_one_channel_exists_private
FAILED tests/channels_tests/channels_listall_test.py::test_when_one_channel_exists_public
FAILED tests/channels_tests/channels_listall_test.py::test_when_multiple_channels_exist
FAILED tests/channels_tests/channels_listall_test.py::test_invalidated_token
======================== 40 failed, 36 passed in 0.61s =========================
